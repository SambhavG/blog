<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="utf-8" />
		<meta name="viewport" content="width=device-width" />
		<link rel="icon" href="./favicon.png" />
		<link rel="icon" href="https://fav.farm/üü¶" />
		<link rel="alternate" type="application/atom+xml" href="/rss.xml" />
		<script type="module">
			const theme = localStorage.getItem('color-scheme')

			theme
				? document.documentElement.setAttribute('color-scheme', theme)
				: localStorage.setItem('color-scheme', 'dark')
		</script>
		
		<link href="./_app/immutable/assets/0.wBZN3QEd.css" rel="stylesheet">
		<link href="./_app/immutable/assets/3.gOD4MmU6.css" rel="stylesheet">
		<link rel="modulepreload" href="./_app/immutable/entry/start.DbeBwdgR.js">
		<link rel="modulepreload" href="./_app/immutable/chunks/entry.BoL_E5gg.js">
		<link rel="modulepreload" href="./_app/immutable/chunks/scheduler.B0edO3JY.js">
		<link rel="modulepreload" href="./_app/immutable/chunks/index.CfxYj6l9.js">
		<link rel="modulepreload" href="./_app/immutable/chunks/control.CYgJF_JY.js">
		<link rel="modulepreload" href="./_app/immutable/entry/app.DUQCeYhl.js">
		<link rel="modulepreload" href="./_app/immutable/chunks/preload-helper.D6kgxu3v.js">
		<link rel="modulepreload" href="./_app/immutable/chunks/index.z0Ohx6yl.js">
		<link rel="modulepreload" href="./_app/immutable/nodes/0.3T-xFXPh.js">
		<link rel="modulepreload" href="./_app/immutable/chunks/spread.CgU5AtxT.js">
		<link rel="modulepreload" href="./_app/immutable/chunks/each.D6YF6ztN.js">
		<link rel="modulepreload" href="./_app/immutable/chunks/config.CvvL7JPP.js">
		<link rel="modulepreload" href="./_app/immutable/nodes/3.D1paQgAx.js">
		<link rel="modulepreload" href="./_app/immutable/chunks/utils.3InfNRpA.js"><title>I tried Bend</title><!-- HEAD_svelte-ylbs26_START --><meta property="og:type" content="article"><meta property="og:title" content="I tried Bend"><!-- HEAD_svelte-ylbs26_END -->
	</head>
	<body data-sveltekit-preload-data="hover">
		<div style="display: contents">  <div class="layout svelte-1sq3us8"><nav class="svelte-scea26"><a href="/" class="title svelte-scea26"><b>Shakespeare</b></a> <button aria-label="Toggle theme" class="svelte-114mtci"><div class="svelte-114mtci"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide-icon lucide lucide-moon "><path d="M12 3a6 6 0 0 0 9 9 9 9 0 1 1-9-9Z"></path></svg> <span data-svelte-h="svelte-397x2m">Dark</span></div> </button> </nav> <main class="svelte-1sq3us8"><div class="transition svelte-vcdv4c"> <article class="svelte-8uncrq"><hgroup><h1 class="svelte-8uncrq">I tried Bend</h1> <p class="svelte-8uncrq">Published at Jun 16, 2024</p></hgroup> <div class="tags svelte-8uncrq"><span class="surface-4 svelte-8uncrq">#Bend</span><span class="surface-4 svelte-8uncrq">#Programming</span></div> <div class="prose"><p data-svelte-h="svelte-1s66koz">I decided to try the new <a href="https://github.com/HigherOrderCO/Bend" rel="nofollow">Bend</a> programming language. Bend aims to be parallel by default: ‚Äúif your code <em>can</em> run in parallel, it <em>will</em> run in parallel‚Äù, but also as easy to write as Python.</p> <p data-svelte-h="svelte-104vkmt">Disclaimer: this post almost certainly has errors and misunderstandings about Bend. My background is as a university math/CS student with some functional programming knowledge.</p> <h2 id="quick-background" data-svelte-h="svelte-1citfpt">Quick background</h2> <p data-svelte-h="svelte-178rgdi">Bend uses two keywords not common in mainstream languages: <em>fold</em> and <em>bend</em>. The idea of <em>fold</em> is to essentially do a Ctrl+F find and replace in a recursive data structure: if I wanted to replace all the leaf nodes in a tree with their doubles, I would compute something like</p> <!-- HTML_TAG_START --><pre class="shiki poimandres" style="background-color:#1b1e28;color:#a6accd" tabindex="0"><code><span class="line"><span style="color:#767C9DB0;font-style:italic"># Default type Tree</span></span>
<span class="line"><span style="color:#A6ACCDC0">type</span><span style="color:#A6ACCD"> Tree:</span></span>
<span class="line"><span style="color:#A6ACCD">  Node &#123; </span><span style="color:#91B4D5">~</span><span style="color:#A6ACCD">left, </span><span style="color:#91B4D5">~</span><span style="color:#A6ACCD">right &#125;</span></span>
<span class="line"><span style="color:#A6ACCD">  Leaf &#123; value &#125;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#91B4D5">def</span><span style="color:#ADD7FF"> doubleTree</span><span style="color:#A6ACCD">(</span><span style="color:#E4F0FB">t</span><span style="color:#A6ACCD">):</span></span>
<span class="line"><span style="color:#A6ACCD">	fold t:</span></span>
<span class="line"><span style="color:#5DE4C7C0">		case</span><span style="color:#A6ACCD"> Tree</span><span style="color:#91B4D5">/</span><span style="color:#A6ACCD">Node:</span></span>
<span class="line"><span style="color:#5DE4C7C0">			return</span><span style="color:#A6ACCD"> Tree</span><span style="color:#91B4D5">/</span><span style="color:#A6ACCD">Node(t.left, t.right)</span></span>
<span class="line"><span style="color:#5DE4C7C0">		case</span><span style="color:#A6ACCD"> Tree</span><span style="color:#91B4D5">/</span><span style="color:#A6ACCD">Leaf:</span></span>
<span class="line"><span style="color:#5DE4C7C0">			return</span><span style="color:#A6ACCD"> Tree</span><span style="color:#91B4D5">/</span><span style="color:#A6ACCD">Leaf(t.value </span><span style="color:#91B4D5">*</span><span style="color:#5DE4C7"> 2</span><span style="color:#A6ACCD">)</span></span></code></pre><!-- HTML_TAG_END --> <p data-svelte-h="svelte-kal97s">Several important things to note here:</p> <ul data-svelte-h="svelte-unff7v"><li>When we have our Tree t, we treat it like a linked list where we ‚Äúgo to‚Äù its left and right nodes whenever it‚Äôs not a leaf, and we double whenever we are at the leaf.</li> <li>The unseen bit of logic here is that whenever we write t.left, or t.right, since those are defined to be recursive (as denoted by the ~ in the default type definition), they are Trees themselves. Thus, the <em>fold</em> folds back and runs the whole chunk of logic on that object too. The Leaf case terminates because value is not a recursive entry. This is essentially a BFS on the tree, where each branch can be computed in parallel, and opportunities for parallel computing like this are how Bend is able to multithread programs.</li></ul> <p data-svelte-h="svelte-1b80s42">The <em>bend</em> operation is somewhat similar, but it‚Äôs used to build up a structure rather than operate on an existing one. The following <em>bend</em> creates a tree of depth d:</p> <!-- HTML_TAG_START --><pre class="shiki poimandres" style="background-color:#1b1e28;color:#a6accd" tabindex="0"><code><span class="line"><span style="color:#91B4D5">def</span><span style="color:#ADD7FF"> makeTree</span><span style="color:#A6ACCD">(</span><span style="color:#E4F0FB">d</span><span style="color:#A6ACCD">):</span></span>
<span class="line"><span style="color:#A6ACCD">	bend d:</span></span>
<span class="line"><span style="color:#A6ACCD">		when d </span><span style="color:#91B4D5">></span><span style="color:#5DE4C7"> 0</span><span style="color:#A6ACCD">:</span></span>
<span class="line"><span style="color:#A6ACCD">			t </span><span style="color:#91B4D5">=</span><span style="color:#A6ACCD"> Tree</span><span style="color:#91B4D5">/</span><span style="color:#A6ACCD">Node(fork(d</span><span style="color:#91B4D5">-</span><span style="color:#5DE4C7">1</span><span style="color:#A6ACCD">), fork(d</span><span style="color:#91B4D5">-</span><span style="color:#5DE4C7">1</span><span style="color:#A6ACCD">))</span></span>
<span class="line"><span style="color:#5DE4C7C0">		else</span><span style="color:#A6ACCD">:</span></span>
<span class="line"><span style="color:#A6ACCD">			t </span><span style="color:#91B4D5">=</span><span style="color:#A6ACCD"> Tree</span><span style="color:#91B4D5">/</span><span style="color:#A6ACCD">Leaf(</span><span style="color:#5DE4C7">1</span><span style="color:#A6ACCD">)</span></span>
<span class="line"><span style="color:#5DE4C7C0">	return</span><span style="color:#A6ACCD"> t</span></span></code></pre><!-- HTML_TAG_END --> <p data-svelte-h="svelte-bgvrmi">Here, <em>fork</em> is used to build another tree with a different argument to bend; each fork loops back to the beginning of bend.</p> <h2 id="goal" data-svelte-h="svelte-1j5vhxy">Goal</h2> <p data-svelte-h="svelte-q5lsin">I‚Äôm going to try to implement a function which multiplies two matrices.</p> <h2 id="shortfall-1-you-cant-really-use-lists" data-svelte-h="svelte-r6ys49">Shortfall 1: You can‚Äôt really use lists</h2> <p data-svelte-h="svelte-157uflz">The first thing I tried was to naturally represent my vectors and matrices as lists and lists of lists respectively. This has a big problem. In Bend, Lists are linked lists. Each list is just the first number and a reference to the rest of the list. To compute the dot product of two equal length lists, we‚Äôd compute:</p> <!-- HTML_TAG_START --><pre class="shiki poimandres" style="background-color:#1b1e28;color:#a6accd" tabindex="0"><code><span class="line"><span style="color:#91B4D5">def</span><span style="color:#ADD7FF"> dot</span><span style="color:#A6ACCD">(</span><span style="color:#E4F0FB">v1</span><span style="color:#A6ACCD">, </span><span style="color:#E4F0FB">v2</span><span style="color:#A6ACCD">):</span></span>
<span class="line"><span style="color:#5DE4C7C0">	match</span><span style="color:#A6ACCD"> v1:</span></span>
<span class="line"><span style="color:#5DE4C7C0">		case</span><span style="color:#A6ACCD"> List</span><span style="color:#91B4D5">/</span><span style="color:#A6ACCD">Nil:</span></span>
<span class="line"><span style="color:#5DE4C7C0">			return</span><span style="color:#5DE4C7"> 0</span></span>
<span class="line"><span style="color:#5DE4C7C0">		case</span><span style="color:#A6ACCD"> List</span><span style="color:#91B4D5">/</span><span style="color:#A6ACCD">Cons:</span></span>
<span class="line"><span style="color:#5DE4C7C0">			match</span><span style="color:#A6ACCD"> v2:</span></span>
<span class="line"><span style="color:#5DE4C7C0">				case</span><span style="color:#A6ACCD"> List</span><span style="color:#91B4D5">/</span><span style="color:#A6ACCD">Nil:</span></span>
<span class="line"><span style="color:#5DE4C7C0">					return</span><span style="color:#5DE4C7"> 0</span><span style="color:#767C9DB0;font-style:italic"> #should never get here</span></span>
<span class="line"><span style="color:#5DE4C7C0">				case</span><span style="color:#A6ACCD"> List</span><span style="color:#91B4D5">/</span><span style="color:#A6ACCD">Cons:</span></span>
<span class="line"><span style="color:#5DE4C7C0">					return</span><span style="color:#A6ACCD"> v1.head</span><span style="color:#91B4D5">*</span><span style="color:#A6ACCD">v2.head</span><span style="color:#91B4D5">+</span><span style="color:#A6ACCD">dot(v1.tail,v2.tail)</span></span></code></pre><!-- HTML_TAG_END --> <p data-svelte-h="svelte-75qjjx">(Note: each List is either a List/Nil or a List/Cons, where List/Nil is an empty list and List/Cons is not. When our tail is empty, it will be a List/Nil)</p> <p data-svelte-h="svelte-14pfgcl">This computation is very sequential, because if the entry-wise products were 1, 2, 3, 4, 5, 6, 7, we‚Äôd end up with the sum 1+ (2+ (3+ (4+ (5+ (6 + 7))))), which must be summed in consecutive order. Bend has no way to optimize a computation like this, as each + depends on another + to complete first.</p> <p data-svelte-h="svelte-sjeu5f">It seems like any computation involving lists will take O(n) time - for this reason, I struggle to think of a situation where the List datatype would ever be useful in a language like Bend, assuming A) it is not used simply as an O(1) sized tuple, and B) the programmer who chose Bend would like to take full advantage of Bend‚Äôs main feature. I mention a caveat in Shortfall 3.</p> <h2 id="shortfall-2-maps-are-tricky" data-svelte-h="svelte-hdr69y">Shortfall 2: Maps are tricky</h2> <p data-svelte-h="svelte-qmm7wq">Bend also has a map datatype. This map works similar to normal maps or dictionaries in other languages, and in theory can be used to simulate an indexable list which avoids the shortfall of regular (linked) Lists.</p> <p data-svelte-h="svelte-1kycqv4">Maps represent the data as a binary tree, where each node is either a Node or a Leaf. Leaves don‚Äôt contain anything, they‚Äôre just end caps; each Node contains a value (either <em>or an actual value) and a reference to left and right nodes. Keys are managed by some scheme which I couldn‚Äôt completely reverse engineer, but each node with some non-</em> value corresponds directly with some valid key.</p> <h3 id="approach-1-direct-traversal" data-svelte-h="svelte-4e8lb1">Approach 1: Direct traversal</h3> <p data-svelte-h="svelte-push8d">I directly use the map structure as a vector and compute dot product recursively. The issue here is that while I can ‚Äúmatch‚Äù the difference between a Leaf and a Node, I can‚Äôt match the difference between a <em>and an actual value, so I couldn‚Äôt find a way to compute dot product recursively as v1.value</em> v2.value + dot(v1.left, v2.left) + dot(v1.right, v2.right) without the * valued nodes getting in the way.</p> <h3 id="approach-2-mergesort-style" data-svelte-h="svelte-16nw8jv">Approach 2: Mergesort style</h3> <p data-svelte-h="svelte-1d2egmj">Alternatively, I can use the map indexing syntax. My function should take the dot product of the left half and right half of the first map with the left half and right half of the second map respectively.</p> <!-- HTML_TAG_START --><pre class="shiki poimandres" style="background-color:#1b1e28;color:#a6accd" tabindex="0"><code><span class="line"><span style="color:#91B4D5">def</span><span style="color:#ADD7FF"> dotProduct</span><span style="color:#A6ACCD">(</span><span style="color:#E4F0FB">v1</span><span style="color:#A6ACCD">, </span><span style="color:#E4F0FB">v2</span><span style="color:#A6ACCD">, </span><span style="color:#E4F0FB">l</span><span style="color:#A6ACCD">, </span><span style="color:#E4F0FB">r</span><span style="color:#A6ACCD">):</span></span>
<span class="line"><span style="color:#5DE4C7C0">  if</span><span style="color:#A6ACCD"> l </span><span style="color:#91B4D5">==</span><span style="color:#A6ACCD"> r:</span></span>
<span class="line"><span style="color:#5DE4C7C0">    return</span><span style="color:#A6ACCD"> v1[l] </span><span style="color:#91B4D5">*</span><span style="color:#A6ACCD"> v2[r]</span></span>
<span class="line"><span style="color:#5DE4C7C0">  else</span><span style="color:#A6ACCD">:</span></span>
<span class="line"><span style="color:#5DE4C7C0">    return</span><span style="color:#A6ACCD"> dotProduct(v1, v2, l, (l</span><span style="color:#91B4D5">+</span><span style="color:#A6ACCD">r)</span><span style="color:#91B4D5">/</span><span style="color:#5DE4C7">2</span><span style="color:#A6ACCD">) </span><span style="color:#91B4D5">+</span><span style="color:#A6ACCD"> dotProduct(v1, v2, (l</span><span style="color:#91B4D5">+</span><span style="color:#A6ACCD">r)</span><span style="color:#91B4D5">/</span><span style="color:#5DE4C7">2</span><span style="color:#91B4D5">+</span><span style="color:#5DE4C7">1</span><span style="color:#A6ACCD">, r)</span></span></code></pre><!-- HTML_TAG_END --> <p data-svelte-h="svelte-1o7dmnp">This turns out to work, but it‚Äôs a bit less efficient than approach 1 would have been - while approach 1 would traverse the tree just once, this approach has to fetch every element individually starting from the top - a slowdown of log n.</p> <p data-svelte-h="svelte-acy9ev">We also have to do some tricky operations to later on when working with full matrices. When we have a vector and a matrix, the dot product of the vector with each row of the matrix gives a number corresponding to each row. We need to somehow merge these dot products into one vector which has the correct indexing.</p> <p data-svelte-h="svelte-12qrtfm">The best (and only), but still problematic way I found to do this was to merge two vectors (and later, two matrices) by pushing one element of the second vector into the first vector, then recursing until the first vector has all of the second vector‚Äôs elements. This requires that the second vector has nonstandard map indices starting at whatever the first vector ends at, or else alignments get messed up.</p> <p data-svelte-h="svelte-10g2ts9">This is definitely not computationally optimal because we are doing a lot of extra work; Bend‚Äôs variables are immutable, so each time we move one element over, we have to copy the first vector or matrix. We‚Äôre also moving each element to a different map O(log n) times instead of O(1) times if we just moved everything into one map by looping through the results. This was the best I could figure out under the restrictions of Bend, however.</p> <p data-svelte-h="svelte-nqhcgx">Code for this approach is in <code>map.bend</code>.</p> <h3 id="quirk-fold-is-a-subset-of-match-but-then-why-use-fold" data-svelte-h="svelte-ntc9ys">Quirk: <em>fold</em> is a subset of <em>match</em>, but then why use fold?</h3> <p data-svelte-h="svelte-otr2cl">The fold operation is syntactic sugar for match:</p> <!-- HTML_TAG_START --><pre class="shiki poimandres" style="background-color:#1b1e28;color:#a6accd" tabindex="0"><code><span class="line"><span style="color:#A6ACCD">fold t:</span></span>
<span class="line"><span style="color:#5DE4C7C0">	case</span><span style="color:#A6ACCD"> Tree</span><span style="color:#91B4D5">/</span><span style="color:#A6ACCD">Node:</span></span>
<span class="line"><span style="color:#5DE4C7C0">		return</span><span style="color:#A6ACCD"> Tree</span><span style="color:#91B4D5">/</span><span style="color:#A6ACCD">Node(t.left, t.right)</span></span>
<span class="line"><span style="color:#5DE4C7C0">	case</span><span style="color:#A6ACCD"> Tree</span><span style="color:#91B4D5">/</span><span style="color:#A6ACCD">Leaf:</span></span>
<span class="line"><span style="color:#5DE4C7C0">		return</span><span style="color:#A6ACCD"> Tree</span><span style="color:#91B4D5">/</span><span style="color:#A6ACCD">Leaf(t.value </span><span style="color:#91B4D5">*</span><span style="color:#5DE4C7"> 2</span><span style="color:#A6ACCD">)</span></span>
<span class="line"></span>
<span class="line"><span style="color:#767C9DB0;font-style:italic">#Same computation using match wrapped in a function</span></span>
<span class="line"><span style="color:#91B4D5">def</span><span style="color:#ADD7FF"> doubleTree</span><span style="color:#A6ACCD">(</span><span style="color:#E4F0FB">t</span><span style="color:#A6ACCD">):</span></span>
<span class="line"><span style="color:#5DE4C7C0">	match</span><span style="color:#A6ACCD"> t:</span></span>
<span class="line"><span style="color:#5DE4C7C0">		case</span><span style="color:#A6ACCD"> Tree</span><span style="color:#91B4D5">/</span><span style="color:#A6ACCD">Node:</span></span>
<span class="line"><span style="color:#5DE4C7C0">			return</span><span style="color:#A6ACCD"> Tree</span><span style="color:#91B4D5">/</span><span style="color:#A6ACCD">Node(doubleTree(t.left), doubleTree(t.right))</span></span>
<span class="line"><span style="color:#5DE4C7C0">		case</span><span style="color:#A6ACCD"> Tree</span><span style="color:#91B4D5">/</span><span style="color:#A6ACCD">Leaf:</span></span>
<span class="line"><span style="color:#5DE4C7C0">			return</span><span style="color:#A6ACCD"> Tree</span><span style="color:#91B4D5">/</span><span style="color:#A6ACCD">Leaf(t.value </span><span style="color:#91B4D5">*</span><span style="color:#5DE4C7"> 2</span><span style="color:#A6ACCD">)</span></span></code></pre><!-- HTML_TAG_END --> <p data-svelte-h="svelte-hjq2i7">This also works if we pass arguments to fold, since functions can take arguments too.</p> <p data-svelte-h="svelte-1ak2dil">The issue with <em>fold</em> is that it only works when the recursive calls only require themselves (and maybe some bookkeeping arguments). This means as soon as we want to use two structures simultaneously, as in my case with dot products, we have to revert to the match syntax.</p> <p data-svelte-h="svelte-4ec9ig">I also think using <em>fold</em> instead of <em>match</em> is rather confusing in general, as the way <em>fold</em> manages recursion is not obvious unless you‚Äôve read and understood the Bend manual (I think <em>match</em> is pretty intuitive in contrast). It seems like <em>fold</em> saves a few keystrokes, but not much more. Using <em>fold</em> feels similar to inlining functions in Python while simultaneously obfuscating their purpose.</p> <p data-svelte-h="svelte-1s8uovp">It can be seen that <em>bend</em> is also syntactic sugar for an if/else statement wrapped in a function (though <em>bend</em> uses the <em>when</em> <em>else</em> syntax; I don‚Äôt know if there‚Äôs a difference.)</p> <h2 id="approach-3-no-maps-custom-trees" data-svelte-h="svelte-143uxqj">Approach 3: No maps, custom trees</h2> <p data-svelte-h="svelte-1q0q6so">I actually tried this approach before the map one.</p> <p data-svelte-h="svelte-150z8si">We create a MatrixTree datatype with four variations: Leaf (a single value), Vector (a tree where each left and right subtree is either a vector or a leaf), Matrix (a tree where each left and right subtree is either a matrix or a vector), and Nil.</p> <!-- HTML_TAG_START --><pre class="shiki poimandres" style="background-color:#1b1e28;color:#a6accd" tabindex="0"><code><span class="line"><span style="color:#A6ACCDC0">type</span><span style="color:#A6ACCD"> MatrixTree:</span></span>
<span class="line"><span style="color:#A6ACCD">  Leaf &#123; value &#125; </span><span style="color:#767C9DB0;font-style:italic">#Single value in a vector</span></span>
<span class="line"><span style="color:#A6ACCD">  Vector &#123;</span><span style="color:#91B4D5">~</span><span style="color:#A6ACCD">left, </span><span style="color:#91B4D5">~</span><span style="color:#A6ACCD">right&#125; </span><span style="color:#767C9DB0;font-style:italic">#Vector of values divided in two</span></span>
<span class="line"><span style="color:#A6ACCD">  Matrix &#123;</span><span style="color:#91B4D5">~</span><span style="color:#A6ACCD">topHalf, </span><span style="color:#91B4D5">~</span><span style="color:#A6ACCD">bottomHalf&#125; </span><span style="color:#767C9DB0;font-style:italic">#Matrix of vectors divided in two</span></span>
<span class="line"><span style="color:#A6ACCD">  Nil</span></span></code></pre><!-- HTML_TAG_END --> <p data-svelte-h="svelte-cqmi6y">From here, our computations are very natural. To multiply two matrices, we need to split the first matrix in half until it‚Äôs all rows, then multiply that row with the second matrix for which we split the same way. Once we‚Äôre at the level of two vectors, we take the dot product by summing the dot products of their respective left and right sides.</p> <p data-svelte-h="svelte-16d8oim">Out of laziness, I made this approach work only good enough for matrices of size a power of 2, but I don‚Äôt think it‚Äôs hard to generalize it to any size with a couple more type matching cases.</p> <p data-svelte-h="svelte-1vjdfup">Code for this approach is in <code>tree.bend</code>.</p> <h2 id="shortfall-3-in-general-implementations-must-be-tailored-for-bend" data-svelte-h="svelte-1ddbe2d">Shortfall 3: In general, implementations must be tailored for Bend</h2> <p data-svelte-h="svelte-et6m2k">While ‚Äúif your code <em>can</em> run in parallel, it <em>will</em> run in parallel‚Äù, it turns out that making sure your code <em>can</em> run in parallel is not so easy. You will almost certainly have to write or redesign your data to work with Bend in a way that you yourself know will be highly parallelizable - in other words, Bend isn‚Äôt magic.</p> <p data-svelte-h="svelte-3umkff">This reduces the value proposition of Bend, at least for me, as I want to get my parallelism ‚Äúfor free‚Äù - I don‚Äôt want to put in just as much work as I would have if I started in python and then added threads myself. Sure, I don‚Äôt have to deal with <em>actual</em> parallelization code, like mutexes and condition variables, but it‚Äôs still quite a bit of wrangling to make Bend compute what I want in a way Bend can actually optimize.</p> <p data-svelte-h="svelte-1iy50qp">One caveat is that we don‚Äôt have to make <em>every</em> operation parallel - in our case, we can choose to only parallelize the operation of initializing each dot product, and keep the dot products themselves as slow O(n) lists - bringing the real world computer into the picture, this is probably fine or even better than the fully parallelized alternative. In exchange we will get a somewhat simpler implementation. Intuitively, I would expect that as soon as we‚Äôve parallelized enough to utilize all of the separate processing units on our computer or GPU, further parallelization isn‚Äôt helpful - and this threshold can be reached pretty quickly.</p> <h3 id="shortfall-4-too-much-matching" data-svelte-h="svelte-tqa67s">Shortfall 4: Too much matching</h3> <p data-svelte-h="svelte-oe7ll7">This is more of an annoyance: every time I want to use a variable, I have to first match its type before I can reference its contents. My code has tall towers of matches and cases when I have any kind of nesting in my types. This may be my fault for not using the <em>object</em> syntax (Bend‚Äôs version of structs) but from first looks at the docs, it doesn‚Äôt seem that much better.</p> <p data-svelte-h="svelte-8nnhsj">Philosophically, it seems like Bend should either be strongly typed, or not have this matching requirement. Instead we have what feels like an in-between state that is certainly not as ergonomic as Python, which does not care and just throws errors when variables aren‚Äôt a compatible type.</p> <h2 id="speed-test" data-svelte-h="svelte-12fulh1">Speed test</h2> <p data-svelte-h="svelte-1tp3xx4">To speed test the two implementations, I encoded the multiplication of two identity matrices. I‚Äôm sure more interesting matrices can be multiplied, but it‚Äôs quite a bit of effort to encode a matrix in either of the two bend schemes. To factor out the time it takes to initialize the matrix, I allow each program to run the computation either once or twice, then subtract. Note that Bend can run in both single-threaded and multithreaded mode, using the run and run-c commands respectively.</p> <p data-svelte-h="svelte-19qiom1">I also wrote a naive python implementation which goes about the computation in a fairly standard dot-product-by-dot-product way, as well as a similar C implementation. I also threw in a numpy version.</p> <p data-svelte-h="svelte-1u7j0uq">All tests were run on a GCP instance with 8 cores and 60 GB of memory except the C one, which didn‚Äôt compile right for GCP so I used my computer. I tried to run Bend‚Äôs CUDA execution on the instance‚Äôs T4, but unfortunately kept running into CUDA errors.</p> <p data-svelte-h="svelte-pp2agd">MT means multithreaded. Times are in seconds. We multiply two identity matrices of size 2^n by 2^n. First four result columns are Bend.</p> <table data-svelte-h="svelte-18upv78"><thead><tr><th>n</th> <th>MT Map</th> <th>Map</th> <th>Tree</th> <th>MT Tree</th> <th>Py</th> <th>MT Py</th> <th>C</th> <th>NP</th></tr></thead> <tbody><tr><td>3</td> <td>.31</td> <td>.12</td> <td></td> <td></td> <td></td> <td></td> <td></td> <td></td></tr> <tr><td>4</td> <td>2.9</td> <td>1.7</td> <td></td> <td></td> <td></td> <td></td> <td></td> <td></td></tr> <tr><td>5</td> <td>43</td> <td>29</td> <td>.48</td> <td></td> <td></td> <td></td> <td></td> <td></td></tr> <tr><td>6</td> <td></td> <td></td> <td>3.9</td> <td>1.1</td> <td></td> <td></td> <td></td> <td></td></tr> <tr><td>7</td> <td></td> <td></td> <td>33</td> <td>3.3</td> <td>.36</td> <td>.27</td> <td></td> <td></td></tr> <tr><td>8</td> <td></td> <td></td> <td></td> <td>20</td> <td>2.7</td> <td>2.2</td> <td></td> <td></td></tr> <tr><td>9</td> <td></td> <td></td> <td></td> <td></td> <td>24</td> <td>19</td> <td>.32</td> <td></td></tr> <tr><td>10</td> <td></td> <td></td> <td></td> <td></td> <td></td> <td></td> <td>2.4</td> <td></td></tr> <tr><td>11</td> <td></td> <td></td> <td></td> <td></td> <td></td> <td></td> <td>53</td> <td></td></tr> <tr><td>12</td> <td></td> <td></td> <td></td> <td></td> <td></td> <td></td> <td></td> <td>.37</td></tr> <tr><td>13</td> <td></td> <td></td> <td></td> <td></td> <td></td> <td></td> <td></td> <td>3.0</td></tr> <tr><td>14</td> <td></td> <td></td> <td></td> <td></td> <td></td> <td></td> <td></td> <td>22</td></tr></tbody></table> <p data-svelte-h="svelte-a5ej3t">Some notes:</p> <ul data-svelte-h="svelte-34sfqz"><li>I ran the C trials on my own computer, as the binary wasn‚Äôt compatible.</li> <li>Some of the fast bend trials were extremely noisy, randomly taking longer than the next order; I‚Äôm not too interested in statistically sound results so I reran those ones.</li> <li>Sometimes the larger bend trials ran out of memory.</li> <li>Though I couldn‚Äôt get Bend‚Äôs CUDA version to work (not a fault of Bend), the docs report a 5x speedup while using CUDA over the regular multithreaded version - this would put the MT Tree on the same order as the Python program.</li></ul> <p data-svelte-h="svelte-m5hqn3">There‚Äôs a lot of interesting data here. First, we find that multithreading the map implementation actually slows it down; this means the map implementation has a very high overhead for multithreading. It‚Äôs also about two orders slower than the tree version; this I expected because the tree version has a lot fewer bookkeeping and overall unnecessary computations involved.</p> <p data-svelte-h="svelte-1n00p21">Multithreading the tree version boosts it by a little over one order, putting it about one order behind the naive python programs.  (One order here is about a factor of 8 in raw computation, since the algorithm we compute is O(x^3) for matrices of size x). The multithreaded Python program only has a slight boost over its normal counterpart. From there, the C and Numpy programs are 2 and 5 orders ahead respectively.</p> <h2 id="conclusion" data-svelte-h="svelte-1cykd0u">Conclusion</h2> <p data-svelte-h="svelte-1olqyvp">I think Bend‚Äôs dream is interesting and cool - our computers have lots of cores and threads, but we almost never write our programs in a way that utilizes them on the first pass. In theory, Bend automates all the heavy lifting of creating threads, mutexes, and so on. In practice, Bend requires a ton of logic finetuning just to make a program compatible with Bend‚Äôs scheme of computation - and this is ignoring the current lack of raw performance, which I‚Äôm sure will improve rapidly over time. I‚Äôm interested to see how Bend progresses in development.</p></div> </article></div></main>  </div> 
			
			<script>
				{
					__sveltekit_x0u1rv = {
						base: new URL(".", location).pathname.slice(0, -1)
					};

					const element = document.currentScript.parentElement;

					const data = [null,null];

					Promise.all([
						import("./_app/immutable/entry/start.DbeBwdgR.js"),
						import("./_app/immutable/entry/app.DUQCeYhl.js")
					]).then(([kit, app]) => {
						kit.start(app, element, {
							node_ids: [0, 3],
							data,
							form: null,
							error: null
						});
					});
				}
			</script>
		</div>
	</body>
</html>
