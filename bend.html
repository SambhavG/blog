<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="utf-8" />
		<meta name="viewport" content="width=device-width" />
		<link rel="icon" href="./favicon.png" />
		<link rel="icon" href="https://fav.farm/üü¶" />
		<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
		<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
		<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
		<link rel="manifest" href="/site.webmanifest">
		<!-- <link rel="alternate" type="application/atom+xml" href="/rss.xml" /> -->
		<link rel="preconnect" href="https://fonts.googleapis.com">
		<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
		<link href="https://fonts.googleapis.com/css2?family=Outfit:wght@100..900&display=swap" rel="stylesheet">
		<script type="module">
			const theme = localStorage.getItem('color-scheme')

			theme
				? document.documentElement.setAttribute('color-scheme', theme)
				: localStorage.setItem('color-scheme', 'dark')
		</script>
		
		<link href="./_app/immutable/assets/0.BlQpJLQq.css" rel="stylesheet">
		<link href="./_app/immutable/assets/3.CVui_4x3.css" rel="stylesheet">
		<link rel="modulepreload" href="./_app/immutable/entry/start.8eeIORQm.js">
		<link rel="modulepreload" href="./_app/immutable/chunks/entry.D5lIx3Rg.js">
		<link rel="modulepreload" href="./_app/immutable/chunks/scheduler.CJ7dzQvO.js">
		<link rel="modulepreload" href="./_app/immutable/chunks/paths.DiDHzGcR.js">
		<link rel="modulepreload" href="./_app/immutable/chunks/control.CYgJF_JY.js">
		<link rel="modulepreload" href="./_app/immutable/entry/app.BXGYdaLC.js">
		<link rel="modulepreload" href="./_app/immutable/chunks/preload-helper.D6kgxu3v.js">
		<link rel="modulepreload" href="./_app/immutable/chunks/index.DW5F0Pto.js">
		<link rel="modulepreload" href="./_app/immutable/nodes/0.Bs-AvZq2.js">
		<link rel="modulepreload" href="./_app/immutable/chunks/config.DxTTfmVZ.js">
		<link rel="modulepreload" href="./_app/immutable/chunks/index.D9MSNRax.js">
		<link rel="modulepreload" href="./_app/immutable/nodes/3.CfPqqrs3.js">
		<link rel="modulepreload" href="./_app/immutable/chunks/utils.BzZo_9Im.js"><title>I Tried Bend</title><!-- HEAD_svelte-ylbs26_START --><meta property="og:type" content="article"><meta property="og:title" content="I Tried Bend"><!-- HEAD_svelte-ylbs26_END -->
	</head>

	<!-- Google tag (gtag.js) -->
	<script async src="https://www.googletagmanager.com/gtag/js?id=G-7VS6Y2PPJF"></script>
	<script>
		window.dataLayer = window.dataLayer || [];
		function gtag(){dataLayer.push(arguments);}
		gtag('js', new Date());

		gtag('config', 'G-7VS6Y2PPJF');
	</script>

	<body data-sveltekit-preload-data="hover">
		<div style="display: contents">  <div class="layout svelte-9rv88k"><nav class="svelte-1kqq7cd"><a href="https://sambhavg.github.io/blog" class="title svelte-1kqq7cd"><b class="svelte-1kqq7cd">Sambhav Gupta</b></a>  </nav> <main class="svelte-9rv88k"><div class="transition svelte-vcdv4c"> <article class="svelte-zpvgpv"><hgroup><h1 class="svelte-zpvgpv">I Tried Bend</h1> <p class="svelte-zpvgpv">June 22, 2024</p></hgroup>  <div class="prose svelte-zpvgpv"><h2 id="contents" data-svelte-h="svelte-mkui86">Contents</h2> <ul data-svelte-h="svelte-s9d7ns"><li><a href="#introduction">Introduction</a></li> <li><a href="#quick-background">Quick background</a></li> <li><a href="#goal">Goal</a></li> <li><a href="#attempt-1-lists">Attempt 1: Lists</a></li> <li><a href="#attempt-2-maps">Attempt 2: Maps</a></li> <li><a href="#attempt-3-maps-merge-sort-style">Attempt 3: Maps, merge-sort style</a></li> <li><a href="#fold-is-basically-just-match-but-why-use-fold"><em>fold</em> is basically just <em>match</em>, but why use <em>fold</em>?</a></li> <li><a href="#attempt-4-no-maps-custom-trees">Attempt 4: No maps, custom trees</a></li> <li><a href="#in-general-implementations-must-be-tailored-for-bend">In general, implementations must be tailored for Bend</a></li> <li><a href="#too-much-matching">Too much matching</a></li> <li><a href="#speed-test">Speed test</a></li> <li><a href="#conclusion">Conclusion</a></li></ul> <h2 id="introduction" data-svelte-h="svelte-p88ani">Introduction</h2> <p data-svelte-h="svelte-135bymc">I decided to try the new <a href="https://github.com/HigherOrderCO/Bend" rel="nofollow">Bend</a> programming language.</p> <p data-svelte-h="svelte-1jc06o8">Bend has two main goals:</p> <ol data-svelte-h="svelte-st58ab"><li>In Bend, if your code can run in parallel, it will run in parallel</li> <li>Bend is as easy to write as Python</li></ol> <p data-svelte-h="svelte-1aqyay">This post is my attempt at a case study with my thoughts about the language mixed in.</p> <p data-svelte-h="svelte-y5ngmz">Disclaimer: this post almost certainly has errors and misunderstandings about Bend. My background is as a university math and CS student with some functional programming knowledge.</p> <p data-svelte-h="svelte-1kfdu8r">Code is in <a href="https://github.com/SambhavG/Bend-Matmul" rel="nofollow">this repo</a>.</p> <h2 id="quick-background" data-svelte-h="svelte-1citfpt">Quick background</h2> <p data-svelte-h="svelte-1ejf3m">Bend uses two keywords not common in mainstream languages: <em>fold</em> and <em>bend</em>. The idea of <em>fold</em> is to essentially do a Ctrl+F find and replace in a recursive data structure: if I wanted to replace all the leaf nodes (with values) in a tree with their doubles, I would write the following function:</p> <!-- HTML_TAG_START --><pre class="shiki poimandres" style="background-color:#1b1e28;color:#a6accd" tabindex="0"><code><span class="line"><span style="color:#767C9DB0;font-style:italic"># This is the default type Tree</span></span>
<span class="line"><span style="color:#A6ACCDC0">type</span><span style="color:#A6ACCD"> Tree:</span></span>
<span class="line"><span style="color:#A6ACCD">  Node &#123; </span><span style="color:#91B4D5">~</span><span style="color:#A6ACCD">left, </span><span style="color:#91B4D5">~</span><span style="color:#A6ACCD">right &#125;</span></span>
<span class="line"><span style="color:#A6ACCD">  Leaf &#123; value &#125;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#91B4D5">def</span><span style="color:#ADD7FF"> doubleTree</span><span style="color:#A6ACCD">(</span><span style="color:#E4F0FB">t</span><span style="color:#A6ACCD">):</span></span>
<span class="line"><span style="color:#A6ACCD">	fold t:</span></span>
<span class="line"><span style="color:#5DE4C7C0">		case</span><span style="color:#A6ACCD"> Tree</span><span style="color:#91B4D5">/</span><span style="color:#A6ACCD">Node:</span></span>
<span class="line"><span style="color:#5DE4C7C0">			return</span><span style="color:#A6ACCD"> Tree</span><span style="color:#91B4D5">/</span><span style="color:#A6ACCD">Node(t.left, t.right)</span></span>
<span class="line"><span style="color:#5DE4C7C0">		case</span><span style="color:#A6ACCD"> Tree</span><span style="color:#91B4D5">/</span><span style="color:#A6ACCD">Leaf:</span></span>
<span class="line"><span style="color:#5DE4C7C0">			return</span><span style="color:#A6ACCD"> Tree</span><span style="color:#91B4D5">/</span><span style="color:#A6ACCD">Leaf(t.value </span><span style="color:#91B4D5">*</span><span style="color:#5DE4C7"> 2</span><span style="color:#A6ACCD">)</span></span></code></pre><!-- HTML_TAG_END --> <p data-svelte-h="svelte-1hkxguz">When we have our Tree t, we treat it like a linked list where we ‚Äúgo to‚Äù its left and right nodes whenever it‚Äôs not a leaf, and we double whenever we are at the leaf.</p> <p data-svelte-h="svelte-5vy4op">The unseen bit of logic here is that whenever we write t.left, or t.right, since those are defined to be recursive (as denoted by the ~ in the type definition), they are Trees themselves. Thus, the <em>fold</em> folds back and runs the whole chunk of logic on that object too. The Leaf case terminates because value is not a recursive entry.</p> <p data-svelte-h="svelte-qiyulm">This is essentially a Breadth First Search on the tree, where each branch can be computed in parallel. Opportunities for parallel computing like this are how Bend is able to multithread programs.</p> <p data-svelte-h="svelte-1hc5t14">What we wrote is (mostly) equivalent to this C program:</p> <!-- HTML_TAG_START --><pre class="shiki poimandres" style="background-color:#1b1e28;color:#a6accd" tabindex="0"><code><span class="line"><span style="color:#91B4D5">void</span><span style="color:#ADD7FF"> doubleTree</span><span style="color:#A6ACCD">(Tree</span><span style="color:#91B4D5">*</span><span style="color:#E4F0FB"> t</span><span style="color:#A6ACCD">) &#123;</span></span>
<span class="line"><span style="color:#767C9DB0;font-style:italic">    // No tree</span></span>
<span class="line"><span style="color:#A6ACCD">    if (</span><span style="color:#91B4D5">!</span><span style="color:#A6ACCD">t) return;</span></span>
<span class="line"><span style="color:#A6ACCD">    </span></span>
<span class="line"><span style="color:#767C9DB0;font-style:italic">    // Leaf</span></span>
<span class="line"><span style="color:#A6ACCD">    if (</span><span style="color:#91B4D5">!</span><span style="color:#E4F0FB">t</span><span style="color:#A6ACCD">-></span><span style="color:#E4F0FB">left</span><span style="color:#91B4D5"> &#x26;&#x26;</span><span style="color:#91B4D5"> !</span><span style="color:#E4F0FB">t</span><span style="color:#A6ACCD">-></span><span style="color:#E4F0FB">right</span><span style="color:#A6ACCD">) &#123;</span></span>
<span class="line"><span style="color:#E4F0FB">        t</span><span style="color:#A6ACCD">-></span><span style="color:#E4F0FB">value</span><span style="color:#91B4D5"> *=</span><span style="color:#5DE4C7"> 2</span><span style="color:#A6ACCD">;</span></span>
<span class="line"><span style="color:#A6ACCD">        return;</span></span>
<span class="line"><span style="color:#A6ACCD">    &#125;</span></span>
<span class="line"><span style="color:#A6ACCD">    </span></span>
<span class="line"><span style="color:#767C9DB0;font-style:italic">    // Non-leaf</span></span>
<span class="line"><span style="color:#E4F0FBD0">    doubleTree</span><span style="color:#A6ACCD">(</span><span style="color:#E4F0FB">t</span><span style="color:#A6ACCD">-></span><span style="color:#E4F0FB">left</span><span style="color:#A6ACCD">);</span></span>
<span class="line"><span style="color:#E4F0FBD0">    doubleTree</span><span style="color:#A6ACCD">(</span><span style="color:#E4F0FB">t</span><span style="color:#A6ACCD">-></span><span style="color:#E4F0FB">right</span><span style="color:#A6ACCD">);</span></span>
<span class="line"><span style="color:#A6ACCD">&#125;</span></span></code></pre><!-- HTML_TAG_END --> <p data-svelte-h="svelte-6gqk89">The <em>bend</em> operation is somewhat similar to <em>fold</em>, but it‚Äôs used to build up a structure rather than operate on an existing one. The following <em>bend</em> creates a tree of depth d:</p> <!-- HTML_TAG_START --><pre class="shiki poimandres" style="background-color:#1b1e28;color:#a6accd" tabindex="0"><code><span class="line"><span style="color:#91B4D5">def</span><span style="color:#ADD7FF"> makeTree</span><span style="color:#A6ACCD">(</span><span style="color:#E4F0FB">d</span><span style="color:#A6ACCD">):</span></span>
<span class="line"><span style="color:#A6ACCD">	bend d:</span></span>
<span class="line"><span style="color:#A6ACCD">		when d </span><span style="color:#91B4D5">></span><span style="color:#5DE4C7"> 0</span><span style="color:#A6ACCD">:</span></span>
<span class="line"><span style="color:#A6ACCD">			t </span><span style="color:#91B4D5">=</span><span style="color:#A6ACCD"> Tree</span><span style="color:#91B4D5">/</span><span style="color:#A6ACCD">Node(fork(d</span><span style="color:#91B4D5">-</span><span style="color:#5DE4C7">1</span><span style="color:#A6ACCD">), fork(d</span><span style="color:#91B4D5">-</span><span style="color:#5DE4C7">1</span><span style="color:#A6ACCD">))</span></span>
<span class="line"><span style="color:#5DE4C7C0">		else</span><span style="color:#A6ACCD">:</span></span>
<span class="line"><span style="color:#A6ACCD">			t </span><span style="color:#91B4D5">=</span><span style="color:#A6ACCD"> Tree</span><span style="color:#91B4D5">/</span><span style="color:#A6ACCD">Leaf(</span><span style="color:#5DE4C7">1</span><span style="color:#A6ACCD">)</span></span>
<span class="line"><span style="color:#5DE4C7C0">	return</span><span style="color:#A6ACCD"> t</span></span></code></pre><!-- HTML_TAG_END --> <p data-svelte-h="svelte-unhppr">Here, <em>fork</em> is used to build another tree with a different argument to bend; each fork loops back to the beginning of bend. Fork is just an explicit version of the thing <em>fold</em> does where it finds and recurses on the recursive arguments.</p> <h2 id="goal" data-svelte-h="svelte-1j5vhxy">Goal</h2> <p data-svelte-h="svelte-q5lsin">I‚Äôm going to try to implement a function which multiplies two matrices.</p> <h2 id="attempt-1-lists" data-svelte-h="svelte-sibjp4">Attempt 1: Lists</h2> <p data-svelte-h="svelte-z596sh">The first thing I tried was to naturally represent my vectors and matrices as lists and lists of lists respectively. This has a big problem. In Bend, Lists are linked lists. Each list is just a head (the first number) and a reference to the rest of the list. To compute the dot product of two equal length lists, we‚Äôd compute:</p> <!-- HTML_TAG_START --><pre class="shiki poimandres" style="background-color:#1b1e28;color:#a6accd" tabindex="0"><code><span class="line"><span style="color:#91B4D5">def</span><span style="color:#ADD7FF"> dot</span><span style="color:#A6ACCD">(</span><span style="color:#E4F0FB">v1</span><span style="color:#A6ACCD">, </span><span style="color:#E4F0FB">v2</span><span style="color:#A6ACCD">):</span></span>
<span class="line"><span style="color:#5DE4C7C0">	match</span><span style="color:#A6ACCD"> v1:</span></span>
<span class="line"><span style="color:#5DE4C7C0">		case</span><span style="color:#A6ACCD"> List</span><span style="color:#91B4D5">/</span><span style="color:#A6ACCD">Nil:</span></span>
<span class="line"><span style="color:#5DE4C7C0">			return</span><span style="color:#5DE4C7"> 0</span></span>
<span class="line"><span style="color:#5DE4C7C0">		case</span><span style="color:#A6ACCD"> List</span><span style="color:#91B4D5">/</span><span style="color:#A6ACCD">Cons:</span></span>
<span class="line"><span style="color:#5DE4C7C0">			match</span><span style="color:#A6ACCD"> v2:</span></span>
<span class="line"><span style="color:#5DE4C7C0">				case</span><span style="color:#A6ACCD"> List</span><span style="color:#91B4D5">/</span><span style="color:#A6ACCD">Nil:</span></span>
<span class="line"><span style="color:#5DE4C7C0">					return</span><span style="color:#5DE4C7"> 0</span><span style="color:#767C9DB0;font-style:italic"> #should never get here</span></span>
<span class="line"><span style="color:#5DE4C7C0">				case</span><span style="color:#A6ACCD"> List</span><span style="color:#91B4D5">/</span><span style="color:#A6ACCD">Cons:</span></span>
<span class="line"><span style="color:#5DE4C7C0">					return</span><span style="color:#A6ACCD"> v1.head</span><span style="color:#91B4D5">*</span><span style="color:#A6ACCD">v2.head</span><span style="color:#91B4D5">+</span><span style="color:#A6ACCD">dot(v1.tail,v2.tail)</span></span></code></pre><!-- HTML_TAG_END --> <p data-svelte-h="svelte-q9i6sg">(Note: each List is either a List/Nil or a List/Cons, where List/Nil is an empty list and List/Cons is not. When our tail is empty, it will be a List/Nil, but until then it will be a List/Cons.)</p> <p data-svelte-h="svelte-1afv4j2">This computation is sequential because if the entry-wise products were 1, 2, 3, 4, 5, 6, 7, we‚Äôd be computing 1+ (2+ (3+ (4+ (5+ (6 + 7))))), which must be computed in consecutive order. Bend has no way to optimize a computation like this, as each + depends on another + to complete first.</p> <p data-svelte-h="svelte-uvpuqz">It seems like any computation involving lists will take O(n) time - for this reason, I struggle to think of a situation where the List datatype would ever be useful in a language like Bend, assuming A) it is not used simply as an O(1) sized tuple, and B) the programmer who chose Bend would like to take full advantage of Bend‚Äôs main feature. I‚Äôll mention a caveat later.</p> <h2 id="attempt-2-maps" data-svelte-h="svelte-10ff6gi">Attempt 2: Maps</h2> <p data-svelte-h="svelte-ksssn2">Bend also has a map datatype. This map works similar to normal maps or dictionaries in other languages, and in theory can be used to simulate an indexable list which avoids the sequentiality of Lists.</p> <p data-svelte-h="svelte-k5guvn">The underlying structure of a Map is interesting; Maps represent the data as a binary tree where each node is either a Node or a Leaf. Leaves are just blank end caps in this case, and don‚Äôt hold data. Each Node either does or doesn‚Äôt contain a value, as well as a reference to left and right nodes. Nodes with no value contain a * instead.</p> <p data-svelte-h="svelte-1h4mrc9">This tree is designed such that every key (that we initialized the map with) corresponds with exactly one node, where for each key k (in binary), the corresponding node is the one we get to by reading the binary little-endian (least to most significant bit) and stepping left for 0, right for 1. For example, all odd numbers end up to the right of the root since they have last digit 1. Keys must be representable as nonnegative integers to make this scheme work.</p> <p data-svelte-h="svelte-1ac1kp5">For this approach, I directly use the map structure as a vector (so m[i] is the i‚Äôth index of the vector) and compute dot product recursively on the tree. The issue I ran into is that while I can ‚Äúmatch‚Äù the difference between a Leaf and a Node, I couldn‚Äôt find a way to match the difference between a * and an actual value, so I couldn‚Äôt find a way to compute dot product recursively as v1.value * v2.value + dot(v1.left, v2.left) + dot(v1.right, v2.right) without the * valued nodes messing up the computation.</p> <h2 id="attempt-3-maps-merge-sort-style" data-svelte-h="svelte-1m3l8ii">Attempt 3: Maps, merge-sort style</h2> <p data-svelte-h="svelte-1d2egmj">Alternatively, I can use the map indexing syntax. My function should take the dot product of the left half and right half of the first map with the left half and right half of the second map respectively.</p> <!-- HTML_TAG_START --><pre class="shiki poimandres" style="background-color:#1b1e28;color:#a6accd" tabindex="0"><code><span class="line"><span style="color:#91B4D5">def</span><span style="color:#ADD7FF"> dotProduct</span><span style="color:#A6ACCD">(</span><span style="color:#E4F0FB">v1</span><span style="color:#A6ACCD">, </span><span style="color:#E4F0FB">v2</span><span style="color:#A6ACCD">, </span><span style="color:#E4F0FB">l</span><span style="color:#A6ACCD">, </span><span style="color:#E4F0FB">r</span><span style="color:#A6ACCD">):</span></span>
<span class="line"><span style="color:#5DE4C7C0">  if</span><span style="color:#A6ACCD"> l </span><span style="color:#91B4D5">==</span><span style="color:#A6ACCD"> r:</span></span>
<span class="line"><span style="color:#5DE4C7C0">    return</span><span style="color:#A6ACCD"> v1[l] </span><span style="color:#91B4D5">*</span><span style="color:#A6ACCD"> v2[r]</span></span>
<span class="line"><span style="color:#5DE4C7C0">  else</span><span style="color:#A6ACCD">:</span></span>
<span class="line"><span style="color:#5DE4C7C0">    return</span><span style="color:#A6ACCD"> dotProduct(v1, v2, l, (l</span><span style="color:#91B4D5">+</span><span style="color:#A6ACCD">r)</span><span style="color:#91B4D5">/</span><span style="color:#5DE4C7">2</span><span style="color:#A6ACCD">) </span><span style="color:#91B4D5">+</span><span style="color:#A6ACCD"> </span></span>
<span class="line"><span style="color:#A6ACCD">	       dotProduct(v1, v2, (l</span><span style="color:#91B4D5">+</span><span style="color:#A6ACCD">r)</span><span style="color:#91B4D5">/</span><span style="color:#5DE4C7">2</span><span style="color:#91B4D5">+</span><span style="color:#5DE4C7">1</span><span style="color:#A6ACCD">, r)</span></span></code></pre><!-- HTML_TAG_END --> <p data-svelte-h="svelte-1t74hzz">This turns out to work, but it‚Äôs a bit less efficient than approach 2 would have been - while approach 2 would traverse the tree just once, this approach has to fetch every element individually starting from the top - a slowdown of log n.</p> <p data-svelte-h="svelte-1egsmzo">We also have to deal with merging our results. When we multiply two vectors, we end up with lots of single numbers that need to go in a new vector, but no straightforward way to merge them all together and keep the correct indexing.</p> <p data-svelte-h="svelte-ub5bwc">The best (and only), but still problematic way I found to do this was to merge two vectors (and later, two matrices) by pushing one element of the second vector into the first vector, then recursing until the first vector has all of the second vector‚Äôs elements. This requires that the second vector has nonstandard map indices starting at whatever the first vector ends at, or else indices will be messed up once the two vectors are mashed together.</p> <p data-svelte-h="svelte-3jphzr">This is definitely not computationally optimal because we are doing a ridiculous amount of extra work; Bend‚Äôs variables are immutable, so each time we move one element over, we have to copy the first vector or matrix (this is probably optimized under the hood, like in Haskell). We‚Äôre also moving each element to a different map O(log n) times instead of O(1) times if we just moved everything into one map by looping through the results. This was the best I could figure out under the restrictions of Bend, however.</p> <p data-svelte-h="svelte-nqhcgx">Code for this approach is in <code>map.bend</code>.</p> <h2 id="fold-is-basically-just-match-but-why-use-fold" data-svelte-h="svelte-1bbvo2u"><em>fold</em> is basically just <em>match</em>, but why use <em>fold</em>?</h2> <p data-svelte-h="svelte-1wrtpx1">Quick tangent: Bend has a <em>match</em> keyword which takes a structure and does something with it based on what its type is. It turns out (as mentioned in the docs) that <em>fold</em> is syntactic sugar for <em>match</em>:</p> <!-- HTML_TAG_START --><pre class="shiki poimandres" style="background-color:#1b1e28;color:#a6accd" tabindex="0"><code><span class="line"><span style="color:#A6ACCD">fold t:</span></span>
<span class="line"><span style="color:#5DE4C7C0">	case</span><span style="color:#A6ACCD"> Tree</span><span style="color:#91B4D5">/</span><span style="color:#A6ACCD">Node:</span></span>
<span class="line"><span style="color:#5DE4C7C0">		return</span><span style="color:#A6ACCD"> Tree</span><span style="color:#91B4D5">/</span><span style="color:#A6ACCD">Node(t.left, t.right)</span></span>
<span class="line"><span style="color:#5DE4C7C0">	case</span><span style="color:#A6ACCD"> Tree</span><span style="color:#91B4D5">/</span><span style="color:#A6ACCD">Leaf:</span></span>
<span class="line"><span style="color:#5DE4C7C0">		return</span><span style="color:#A6ACCD"> Tree</span><span style="color:#91B4D5">/</span><span style="color:#A6ACCD">Leaf(t.value </span><span style="color:#91B4D5">*</span><span style="color:#5DE4C7"> 2</span><span style="color:#A6ACCD">)</span></span>
<span class="line"></span>
<span class="line"><span style="color:#767C9DB0;font-style:italic">#Same computation using match wrapped in a function</span></span>
<span class="line"><span style="color:#91B4D5">def</span><span style="color:#ADD7FF"> doubleTree</span><span style="color:#A6ACCD">(</span><span style="color:#E4F0FB">t</span><span style="color:#A6ACCD">):</span></span>
<span class="line"><span style="color:#5DE4C7C0">	match</span><span style="color:#A6ACCD"> t:</span></span>
<span class="line"><span style="color:#5DE4C7C0">		case</span><span style="color:#A6ACCD"> Tree</span><span style="color:#91B4D5">/</span><span style="color:#A6ACCD">Node:</span></span>
<span class="line"><span style="color:#5DE4C7C0">			return</span><span style="color:#A6ACCD"> Tree</span><span style="color:#91B4D5">/</span><span style="color:#A6ACCD">Node(doubleTree(t.left), </span></span>
<span class="line"><span style="color:#A6ACCD">			                 doubleTree(t.right))</span></span>
<span class="line"><span style="color:#5DE4C7C0">		case</span><span style="color:#A6ACCD"> Tree</span><span style="color:#91B4D5">/</span><span style="color:#A6ACCD">Leaf:</span></span>
<span class="line"><span style="color:#5DE4C7C0">			return</span><span style="color:#A6ACCD"> Tree</span><span style="color:#91B4D5">/</span><span style="color:#A6ACCD">Leaf(t.value </span><span style="color:#91B4D5">*</span><span style="color:#5DE4C7"> 2</span><span style="color:#A6ACCD">)</span></span></code></pre><!-- HTML_TAG_END --> <p data-svelte-h="svelte-uekaqw">This also works if we pass arguments to <em>fold</em> (which requires a bit of extra syntax), since functions can take arguments too.</p> <p data-svelte-h="svelte-3taq16">The issue with <em>fold</em> as a replacement of loops is that <em>fold</em> works best when the recursive calls only require themselves and some bookkeeping arguments. When we want to use two structures simultaneously, as in my case with dot products, the <em>fold</em> syntax becomes very long and awkward, as we have to pass the second structure as a bookkeeping argument and then <em>match</em> it to its type when we want to use it - we might as well use two nested <em>match</em> statements instead of a <em>match</em> inside a <em>fold</em>.</p> <p data-svelte-h="svelte-xtiskq">I also think using <em>fold</em> instead of <em>match</em> is rather confusing in general, as the way <em>fold</em> manages recursion is not obvious (to me) unless you‚Äôve (I‚Äôve) read and understood the Bend manual. I think <em>match</em> is pretty intuitive in contrast.</p> <p data-svelte-h="svelte-1s8uovp">It can be seen that <em>bend</em> is also syntactic sugar for an if/else statement wrapped in a function (though <em>bend</em> uses the <em>when</em> <em>else</em> syntax; I don‚Äôt know if there‚Äôs a difference.)</p> <h2 id="attempt-4-no-maps-custom-trees" data-svelte-h="svelte-1641qdv">Attempt 4: No maps, custom trees</h2> <p data-svelte-h="svelte-1ui4l2u">Here, we trim the desire for baked-in indexability and use a barebones tree structure to represent matrices and vectors.</p> <p data-svelte-h="svelte-150z8si">We create a MatrixTree datatype with four variations: Leaf (a single value), Vector (a tree where each left and right subtree is either a vector or a leaf), Matrix (a tree where each left and right subtree is either a matrix or a vector), and Nil.</p> <!-- HTML_TAG_START --><pre class="shiki poimandres" style="background-color:#1b1e28;color:#a6accd" tabindex="0"><code><span class="line"><span style="color:#A6ACCDC0">type</span><span style="color:#A6ACCD"> MatrixTree:</span></span>
<span class="line"><span style="color:#767C9DB0;font-style:italic">	#Single value in a vector</span></span>
<span class="line"><span style="color:#A6ACCD">	Leaf &#123; value &#125;</span></span>
<span class="line"><span style="color:#767C9DB0;font-style:italic">	#Vector of values divided in two</span></span>
<span class="line"><span style="color:#A6ACCD">	Vector &#123;</span><span style="color:#91B4D5">~</span><span style="color:#A6ACCD">left, </span><span style="color:#91B4D5">~</span><span style="color:#A6ACCD">right&#125;</span></span>
<span class="line"><span style="color:#767C9DB0;font-style:italic">	#Matrix of vectors divided in two</span></span>
<span class="line"><span style="color:#A6ACCD">	Matrix &#123;</span><span style="color:#91B4D5">~</span><span style="color:#A6ACCD">topHalf, </span><span style="color:#91B4D5">~</span><span style="color:#A6ACCD">bottomHalf&#125;</span></span>
<span class="line"><span style="color:#A6ACCD">	Nil</span></span></code></pre><!-- HTML_TAG_END --> <p data-svelte-h="svelte-1btyjgl">From here, our computations are very natural. To multiply two matrices, we need to repeatedly split the first matrix in half until it‚Äôs all rows, then multiply each row with the second matrix which we split the same way. Once we‚Äôve recursed down to the level of two vectors, we can take the dot product by summing the dot products of their respective left and right sides.</p> <p data-svelte-h="svelte-16d8oim">Out of laziness, I made this approach work only good enough for matrices of size a power of 2, but I don‚Äôt think it‚Äôs hard to generalize it to any size with a couple more type matching cases.</p> <p data-svelte-h="svelte-1vjdfup">Code for this approach is in <code>tree.bend</code>.</p> <h2 id="in-general-implementations-must-be-tailored-for-bend" data-svelte-h="svelte-11l3hwn">In general, implementations must be tailored for Bend</h2> <p data-svelte-h="svelte-1ge0d0s">While ‚Äúif your code <em>can</em> run in parallel, it <em>will</em> run in parallel‚Äù, what I learned from designing these two matrix data structures is that it turns out making sure your code <em>can</em> run in parallel is not so easy. You will almost certainly have to write or redesign your data to work with Bend in a way that you yourself know will be highly parallelizable - in other words, Bend isn‚Äôt magic.</p> <p data-svelte-h="svelte-hs67zz">This reduces the value proposition of Bend, at least for me, as I want to get my parallelism ‚Äúfor free‚Äù - I don‚Äôt want to put in on the order of the same amount of work as I would have if I started in python and then added threads myself. Sure, I don‚Äôt have to deal with <em>actual</em> parallelization code, like mutexes and condition variables, but it‚Äôs still quite a bit of wrangling to make Bend compute what I want in a way Bend can actually optimize.</p> <p data-svelte-h="svelte-1569d9d">One caveat is that we don‚Äôt have to make <em>every</em> operation parallel - in our case, we can choose to only parallelize the operation of initializing each dot product, and keep the dot products themselves as slow O(n) lists - bringing the real world computer into the picture, this is probably fine or even better than the fully parallelized alternative. In exchange we will get a somewhat simpler implementation.</p> <p data-svelte-h="svelte-11hpdqg">Intuitively, I would expect that as soon as we‚Äôve parallelized enough to utilize all of the separate processing units on our computer or GPU, further parallelization isn‚Äôt helpful - and this threshold can be reached pretty quickly.</p> <h2 id="too-much-matching" data-svelte-h="svelte-zayv58">Too much matching</h2> <p data-svelte-h="svelte-1g5qvmp">This is a bit of an annoyance I had: every time I want to use a variable, I have to first <em>match</em> its type before I can reference its contents. My code has tall towers of <em>match</em> es and <em>case</em> s when I have any kind of nesting in my types.</p> <p data-svelte-h="svelte-2ny23r">Philosophically, it seems like Bend should either be strongly typed or not have this matching requirement. What Bend has is certainly not as ergonomic as Python, which does not care and just throws errors when variables aren‚Äôt a compatible type.</p> <h2 id="speed-test" data-svelte-h="svelte-12fulh1">Speed test</h2> <p data-svelte-h="svelte-5tkv2o">To test the two implementations, I encoded the multiplication of two identity matrices. I‚Äôm sure more interesting matrices can be multiplied, but it‚Äôs quite a bit of effort to encode a particular matrix in either of the two bend schemes. To factor out the time it takes to initialize the matrix, I allow each program to run the computation either once or twice, then subtract. Note that Bend can run in both single-threaded and multithreaded mode, using the run and run-c arguments respectively.</p> <p data-svelte-h="svelte-17x1ubp">I also wrote a naive python implementation which goes about the computation in a fairly standard dot-product-by-dot-product way, as well as a similar C implementation. I had ChatGPT generate a multithreaded version of the python code (don‚Äôt be surprised if it‚Äôs not good code). Finally, I threw in a Numpy version.</p> <p data-svelte-h="svelte-1wghyjk">All tests were run on a GCP instance with 8 cores and 60 GB of memory except the C one, which I ran on my computer because the binary wasn‚Äôt compatible. I tried Bend‚Äôs CUDA execution on the GCP instance‚Äôs T4 GPU, but unfortunately kept running into CUDA errors I couldn‚Äôt troubleshoot.</p> <p data-svelte-h="svelte-j8wp2n">In the table, we multiply two identity matrices of size 2^n by 2^n. Times are in seconds. MT means multithreaded.  First four result columns are Bend.</p> <table data-svelte-h="svelte-1oxzbov"><thead><tr><th>n</th> <th>MT Map</th> <th>Map</th> <th>Tree</th> <th>MT Tree</th> <th>Py</th> <th>MT Py</th> <th>C</th> <th>Numpy</th></tr></thead> <tbody><tr><td>3</td> <td>.31</td> <td>.12</td> <td></td> <td></td> <td></td> <td></td> <td></td> <td></td></tr> <tr><td>4</td> <td>2.9</td> <td>1.7</td> <td></td> <td></td> <td></td> <td></td> <td></td> <td></td></tr> <tr><td>5</td> <td>43</td> <td>29</td> <td>.48</td> <td></td> <td></td> <td></td> <td></td> <td></td></tr> <tr><td>6</td> <td></td> <td></td> <td>3.9</td> <td>1.1</td> <td></td> <td></td> <td></td> <td></td></tr> <tr><td>7</td> <td></td> <td></td> <td>33</td> <td>3.3</td> <td>.36</td> <td>.27</td> <td></td> <td></td></tr> <tr><td>8</td> <td></td> <td></td> <td></td> <td>20</td> <td>2.7</td> <td>2.2</td> <td></td> <td></td></tr> <tr><td>9</td> <td></td> <td></td> <td></td> <td></td> <td>24</td> <td>19</td> <td>.32</td> <td></td></tr> <tr><td>10</td> <td></td> <td></td> <td></td> <td></td> <td></td> <td></td> <td>2.4</td> <td></td></tr> <tr><td>11</td> <td></td> <td></td> <td></td> <td></td> <td></td> <td></td> <td>53</td> <td></td></tr> <tr><td>12</td> <td></td> <td></td> <td></td> <td></td> <td></td> <td></td> <td></td> <td>.37</td></tr> <tr><td>13</td> <td></td> <td></td> <td></td> <td></td> <td></td> <td></td> <td></td> <td>3.0</td></tr> <tr><td>14</td> <td></td> <td></td> <td></td> <td></td> <td></td> <td></td> <td></td> <td>22</td></tr></tbody></table> <p data-svelte-h="svelte-a5ej3t">Some notes:</p> <ul data-svelte-h="svelte-671rmg"><li>Some of the fast bend trials were extremely noisy, sometimes taking longer than the next order of n; I‚Äôm not too interested in statistically sound results so I reran those ones.</li> <li>Sometimes the larger bend trials ran out of memory.</li> <li>Though I couldn‚Äôt get Bend‚Äôs CUDA version to work (not a fault of Bend), the docs report a 5x speedup while using CUDA over the regular multithreaded version - this would put the MT Tree on the same order as the (sequential) Python program. (Though this 5x speedup was computed on a small, sub 1s timescale, and I‚Äôd expect CUDA to have high multithreading overhead.)</li></ul> <p data-svelte-h="svelte-177hvj5">There‚Äôs some interesting data here. First, we find that multithreading the map implementation actually slows it down, so it has a very high overhead for multithreading. It‚Äôs also about two orders slower than the tree version; this I expected because the tree version has a lot fewer bookkeeping and overall unnecessary computations involved.</p> <p data-svelte-h="svelte-lkkx25">Multithreading the tree version boosts it by a little over one order, putting it about one order behind the naive python program.  (One order here is about a factor of 8 in raw computation, since the algorithm we compute is O(x^3) for matrices of size x). The multithreaded Python program only has a slight boost over its normal counterpart. From there, the C and Numpy programs are 2 and 5 orders ahead respectively (Numpy might take advantage of the identity-ness of the matrices).</p> <p data-svelte-h="svelte-exe35p">Anecdotally, I also think there‚Äôs some role being played by memory and garbage collection; the first trial I run in Bend on a fresh restart seems less likely to hit OOM errors than later ones.</p> <h2 id="conclusion" data-svelte-h="svelte-1cykd0u">Conclusion</h2> <p data-svelte-h="svelte-1j20a9j">I think what I kind of wanted from Bend going into this is the ability to look at a piece of code like:</p> <!-- HTML_TAG_START --><pre class="shiki poimandres" style="background-color:#1b1e28;color:#a6accd" tabindex="0"><code><span class="line"><span style="color:#91B4D5">int</span><span style="color:#A6ACCD"> x </span><span style="color:#91B4D5">=</span><span style="color:#5DE4C7"> 0</span><span style="color:#A6ACCD">;</span></span>
<span class="line"><span style="color:#A6ACCD">for (</span><span style="color:#91B4D5">int</span><span style="color:#A6ACCD"> i </span><span style="color:#91B4D5">=</span><span style="color:#5DE4C7"> 0</span><span style="color:#A6ACCD">; i </span><span style="color:#91B4D5">&#x3C;</span><span style="color:#5DE4C7"> 100</span><span style="color:#A6ACCD">; i</span><span style="color:#91B4D5">++</span><span style="color:#A6ACCD">) &#123;</span></span>
<span class="line"><span style="color:#A6ACCD">	x </span><span style="color:#91B4D5">+=</span><span style="color:#A6ACCD"> i;</span></span>
<span class="line"><span style="color:#A6ACCD">&#125;</span></span></code></pre><!-- HTML_TAG_END --> <p data-svelte-h="svelte-z649ra">and for Bend to read this and (through some math-y functional programming magic) say ‚ÄúOh look! Each iteration of the for loop doesn‚Äôt actually depend on what happened in any of the other iterations. I can parallelize this.‚Äù and compile/transpile/run something like</p> <!-- HTML_TAG_START --><pre class="shiki poimandres" style="background-color:#1b1e28;color:#a6accd" tabindex="0"><code><span class="line"><span style="color:#91B4D5">void</span><span style="color:#ADD7FF"> add_to_sum</span><span style="color:#A6ACCD">(</span><span style="color:#91B4D5">int</span><span style="color:#E4F0FB"> value</span><span style="color:#A6ACCD">, std::atomic</span><span style="color:#91B4D5">&#x3C;int>&#x26;</span><span style="color:#E4F0FB"> result</span><span style="color:#A6ACCD">) &#123;</span></span>
<span class="line"><span style="color:#A6ACCD">    result </span><span style="color:#91B4D5">+=</span><span style="color:#A6ACCD"> value;</span></span>
<span class="line"><span style="color:#A6ACCD">&#125;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#A6ACCD">atomic</span><span style="color:#91B4D5">&#x3C;int></span><span style="color:#ADD7FF"> x</span><span style="color:#A6ACCD">(</span><span style="color:#5DE4C7">0</span><span style="color:#A6ACCD">);</span></span>
<span class="line"><span style="color:#A6ACCD">vector</span><span style="color:#91B4D5">&#x3C;</span><span style="color:#A6ACCD">thread</span><span style="color:#91B4D5">></span><span style="color:#A6ACCD"> threads;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#A6ACCD">for (</span><span style="color:#91B4D5">int</span><span style="color:#A6ACCD"> i </span><span style="color:#91B4D5">=</span><span style="color:#5DE4C7"> 0</span><span style="color:#A6ACCD">; i </span><span style="color:#91B4D5">&#x3C;</span><span style="color:#5DE4C7"> 100</span><span style="color:#A6ACCD">; i</span><span style="color:#91B4D5">++</span><span style="color:#A6ACCD">) &#123;</span></span>
<span class="line"><span style="color:#E4F0FB">	threads</span><span style="color:#A6ACCD">.</span><span style="color:#ADD7FF">push_back</span><span style="color:#A6ACCD">(add_to_sum, i, </span><span style="color:#E4F0FBD0">ref</span><span style="color:#A6ACCD">(x));</span></span>
<span class="line"><span style="color:#A6ACCD">&#125;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#A6ACCD">for (auto</span><span style="color:#91B4D5">&#x26;</span><span style="color:#A6ACCD"> t : threads) &#123;</span></span>
<span class="line"><span style="color:#E4F0FB">	t</span><span style="color:#A6ACCD">.</span><span style="color:#ADD7FF">join</span><span style="color:#A6ACCD">();</span></span>
<span class="line"><span style="color:#A6ACCD">&#125;</span></span></code></pre><!-- HTML_TAG_END --> <p data-svelte-h="svelte-zwltr7">(Under the assumption that addition is a really long and tedious computation. The relative ease of computing dot products is perhaps a major flaw in my case study, as it likely fails to play to Bend‚Äôs strength.)</p> <p data-svelte-h="svelte-1lyrqec">Instead, it feels like I have to spell it out for Bend in my implementation. In other words, it feels like I myself would be able to write an interpreter for Bend code that can be maximally multithreaded - just spawn new threads whenever I hit a piece of logic with function calls I can handle separately. It would be really hard and definitely above my pay grade, but the point is I can see how it might be done.</p> <p data-svelte-h="svelte-29b1bb">I think Bend‚Äôs dream is interesting and cool - our computers have lots of cores and threads, but we almost never write our programs in a way that utilizes them on the first pass. In theory, Bend automates all the heavy lifting of creating threads, mutexes, and so on. In practice, Bend requires a ton of logic fine-tuning just to make a program compatible with Bend‚Äôs scheme of computation - and this is ignoring the current lack of raw performance, which I‚Äôm sure will improve rapidly over time. I‚Äôm interested to see how Bend progresses in development and where it will be a year or two from now.</p></div> </article></div></main> <footer class="svelte-1fvv9s8" data-svelte-h="svelte-egjb02"><p class="svelte-1fvv9s8">Made by <a href="https://sambhavg.github.io/" target="_blank">Sambhav Gupta</a></p> </footer> </div> 
			
			<script>
				{
					__sveltekit_bxy18b = {
						base: new URL(".", location).pathname.slice(0, -1),
						assets: "/blog"
					};

					const element = document.currentScript.parentElement;

					const data = [null,null];

					Promise.all([
						import("./_app/immutable/entry/start.8eeIORQm.js"),
						import("./_app/immutable/entry/app.BXGYdaLC.js")
					]).then(([kit, app]) => {
						kit.start(app, element, {
							node_ids: [0, 3],
							data,
							form: null,
							error: null
						});
					});
				}
			</script>
		</div>
	</body>
</html>
