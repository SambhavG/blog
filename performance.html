<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="utf-8" />
		<meta name="viewport" content="width=device-width" />
		<link rel="icon" href="./favicon.png" />
		<link rel="icon" href="https://fav.farm/üü¶" />
		<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
		<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
		<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
		<link rel="manifest" href="/site.webmanifest">
		<!-- <link rel="alternate" type="application/atom+xml" href="/rss.xml" /> -->
		<link rel="preconnect" href="https://fonts.googleapis.com">
		<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
		<link href="https://fonts.googleapis.com/css2?family=Outfit:wght@100..900&display=swap" rel="stylesheet">
		<script type="module">
			const theme = localStorage.getItem('color-scheme')

			theme
				? document.documentElement.setAttribute('color-scheme', theme)
				: localStorage.setItem('color-scheme', 'dark')
		</script>
		
		<link href="./_app/immutable/assets/0.BlQpJLQq.css" rel="stylesheet">
		<link href="./_app/immutable/assets/3.CVui_4x3.css" rel="stylesheet">
		<link rel="modulepreload" href="./_app/immutable/entry/start.8eeIORQm.js">
		<link rel="modulepreload" href="./_app/immutable/chunks/entry.D5lIx3Rg.js">
		<link rel="modulepreload" href="./_app/immutable/chunks/scheduler.CJ7dzQvO.js">
		<link rel="modulepreload" href="./_app/immutable/chunks/paths.DiDHzGcR.js">
		<link rel="modulepreload" href="./_app/immutable/chunks/control.CYgJF_JY.js">
		<link rel="modulepreload" href="./_app/immutable/entry/app.BXGYdaLC.js">
		<link rel="modulepreload" href="./_app/immutable/chunks/preload-helper.D6kgxu3v.js">
		<link rel="modulepreload" href="./_app/immutable/chunks/index.DW5F0Pto.js">
		<link rel="modulepreload" href="./_app/immutable/nodes/0.Bs-AvZq2.js">
		<link rel="modulepreload" href="./_app/immutable/chunks/config.DxTTfmVZ.js">
		<link rel="modulepreload" href="./_app/immutable/chunks/index.D9MSNRax.js">
		<link rel="modulepreload" href="./_app/immutable/nodes/3.CfPqqrs3.js">
		<link rel="modulepreload" href="./_app/immutable/chunks/utils.BzZo_9Im.js"><title>I tried Anthropic's Performance Takehome</title><!-- HEAD_svelte-ylbs26_START --><meta property="og:type" content="article"><meta property="og:title" content="I tried Anthropic's Performance Takehome"><!-- HEAD_svelte-ylbs26_END -->
	</head>

	<!-- Google tag (gtag.js) -->
	<script async src="https://www.googletagmanager.com/gtag/js?id=G-7VS6Y2PPJF"></script>
	<script>
		window.dataLayer = window.dataLayer || [];
		function gtag(){dataLayer.push(arguments);}
		gtag('js', new Date());

		gtag('config', 'G-7VS6Y2PPJF');
	</script>

	<body data-sveltekit-preload-data="hover">
		<div style="display: contents">  <div class="layout svelte-9rv88k"><nav class="svelte-1kqq7cd"><a href="https://sambhavg.github.io/blog" class="title svelte-1kqq7cd"><b class="svelte-1kqq7cd">Sambhav Gupta</b></a>  </nav> <main class="svelte-9rv88k"><div class="transition svelte-vcdv4c"> <article class="svelte-zpvgpv"><hgroup><h1 class="svelte-zpvgpv">I tried Anthropic's Performance Takehome</h1> <p class="svelte-zpvgpv">February 9, 2026</p></hgroup>  <div class="prose svelte-zpvgpv"><p data-svelte-h="svelte-1rowf0r">I attempted <a href="https://github.com/anthropics/original_performance_takehome" rel="nofollow">Anthropic‚Äôs performance take-home exam</a> released recently. I achieved a final score of 1218 cycles, beating both the recruiting threshold (1487) and Opus 4.5‚Äôs best score (1363). <a href="https://github.com/SambhavG/anthropic-performance" rel="nofollow">My solution</a> is relatively simple and interpretable, combining a couple of basic theoretical and practical optimizations. Scroll to the bottom for a simulation of the solution in the form of my intermediate representation.</p> <h2 id="contents" data-svelte-h="svelte-mkui86">Contents</h2> <ul data-svelte-h="svelte-1xmidpa"><li><a href="#problem-statement">Problem statement</a> <ul><li><a href="#the-processor">The Processor</a></li> <li><a href="#the-algorithm">The Algorithm</a></li></ul></li> <li><a href="#compute-and-memory-bounds">Compute and Memory Bounds</a> <ul><li><a href="#ops">Ops</a> <ul><li><a href="#aside-main-memory-indexing">Aside: Main Memory Indexing</a></li></ul></li> <li><a href="#memory">Memory</a> <ul><li><a href="#muxing">Muxing</a></li></ul></li></ul></li> <li><a href="#symbolic-intermediate-representation">Symbolic Intermediate Representation</a></li> <li><a href="#compiling">Compiling</a></li> <li><a href="#first-shot-2107-cycles">First Shot (2107 cycles)</a></li> <li><a href="#mux-level-0-1860-cycles">‚ÄúMux‚Äù Level 0 (1860 cycles)</a></li> <li><a href="#mux-level-1-1722-cycles">Mux Level 1 (1722 cycles)</a></li> <li><a href="#mux-level-2-1655-cycles">Mux Level 2 (1655 cycles)</a></li> <li><a href="#mux-level-3-1620-cycles-but-out-of-registers">Mux Level 3 (1620 cycles, but out of registers)</a></li> <li><a href="#mux-level-3-rotated-input-1548-cycles">Mux Level 3, Rotated Input (1548 cycles)</a></li> <li><a href="#optimize-preamble-1498-cycles">Optimize Preamble (1498 cycles)</a></li> <li><a href="#use-the-rest-of-the-alu-1240-cycles">Use the rest of the ALU (1240 cycles)</a></li> <li><a href="#optimize-tail-1218-cycles">Optimize Tail (1218 cycles)</a></li> <li><a href="#final-thoughts">Final thoughts</a></li></ul> <h1 id="problem-statement" data-svelte-h="svelte-1hoea67">Problem statement</h1> <h2 id="the-processor" data-svelte-h="svelte-4ydllv">The Processor</h2> <p data-svelte-h="svelte-4g044a">You‚Äôre given a single instruction multiple data (SIMD) processor simulator. This processor can perform math operations on vectors of length 8.</p> <p data-svelte-h="svelte-1xo5n0d">The processor can perform up to 12 scalar ALU operations, 6 vectorized ALU operations, 2 loads, 2 stores, and a flow control operation all in one clock cycle, but no two instructions in the same cycle can read what the other writes.</p> <p data-svelte-h="svelte-17nez0u">There‚Äôs a RAM ‚Äúscratch memory‚Äù of 1536 ordered registers, which is what the ALU and vector instructions can operate on. Vector instructions have to target 8 contiguous scalar registers. All the actual problem data starts on main memory, and must be loaded into scratch memory before it can be used.</p> <h2 id="the-algorithm" data-svelte-h="svelte-19y3thh">The Algorithm</h2> <p data-svelte-h="svelte-145ir2o">The algorithm you‚Äôre asked to compute is as follows: you‚Äôre given a binary tree of height 10 (so the layers have 1, 2, 4, ‚Ä¶, 2^10 nodes each, for 11 distinct layers and 2047 nodes total). Each node has a random integer value. You‚Äôre also given an array of input values, which has length batch_size=256. For each input value, you start at the top of the tree and xor your value with the top node‚Äôs value, then hash this new value with a given hash function. If your result is even, you take the left branch of the tree, otherwise you go right. You repeat this operation 16 times total, each time going down a level of the tree, and eventually looping around to the top node of the tree when you get to the last layer (which will always happen after round 11). This traversal is completely independent for each of the 256 input values.</p> <p data-svelte-h="svelte-17g7mb2">For the tree, we can compute child values using the tree indexing trick where the top node is at index 1 and every node x‚Äôs child is at index 2x and 2x+1 for left and right. Given this, there are three distinct phases to each of the 16 hops, given a current value v and index i (initialized to 1):</p> <ol data-svelte-h="svelte-pa9qgq"><li>Get the corresponding tree node i‚Äôs value v‚Äô and xor it: v = v xor v‚Äô</li> <li>Hash v: v = hash(v)</li> <li>Compute the next index: i = 2i + (v%2), and if i&gt;2047, i = 1</li></ol> <p data-svelte-h="svelte-1pkha98">Notably, we‚Äôll know at compile time when the loopback happens since we can compile our kernel for a specific testcase (where only the inner tree data is random but all the size parameters are fixed and known), so we don‚Äôt actually have to check this if statement in code (we can just directly set all the indices back to 1).</p> <h1 id="compute-and-memory-bounds" data-svelte-h="svelte-9eue7d">Compute and Memory Bounds</h1> <h2 id="ops" data-svelte-h="svelte-mozfji">Ops</h2> <p data-svelte-h="svelte-utpxyc">The baseline code requires 147734 total instructions to compute the algorithm on the given test case. The baseline code only uses singular ALU ops and no SIMD/vectorization at all in any clock cycle. We‚Äôre only tested on this one specific test case, namely 256 inputs, height 10 tree, and 16 rounds, so we can overfit for convenience in this analysis.</p> <p data-svelte-h="svelte-1lgfz2v">The processor is capable of roughly 8x6+12 = 60 regular arithmetic operations per clock cycle, assuming that we always fuse vectorized multiplies and adds into a multiply_add.</p> <p data-svelte-h="svelte-1p88lt9">The initial xor with the value in the tree takes 1 op. The hash function mentioned earlier has 6 stages, each requiring 3 operations, and we have to do an additional xor at the beginning. However, it turns out the multiply_add can be used to crush three of those stages down to one operation each (these stages can be written as the sum of x, x shifted left by some amount, and a hardcoded number, which boils down to x times 2^n+1 plus c for some n and c), so we only need 12 ops for our hash. Computing the next node to hop to is a bit trickier and implementation-dependent, but we‚Äôll assume for now it requires an &amp; with 1 for the modulo check, a doubling of the old index pointer, and an addition of that 0 or 1 from the modulo check, so three more ALU ops. This is a total of 16 operations per batch item per round.</p> <p data-svelte-h="svelte-imp4iq">Then for a batch size of 256 and 16 rounds, we‚Äôll need 256x16x16=65536 operations, or roughly 1092 clock cycles for compute. Note that we‚Äôre allowed to load and store at the same time as our compute cycles, so this is a lower bound on performance possible assuming we compute exactly as described. Opus 4.5‚Äôs launch performance was 1487 cycles, and its best performance was 1363 cycles.</p> <h3 id="aside-main-memory-indexing" data-svelte-h="svelte-s49ez1">Aside: Main Memory Indexing</h3> <p data-svelte-h="svelte-gkqa2r">The tree values in main memory start at address 7, meaning the first node is at main_mem[7].  We can only address main memory by putting the address we want in a scratch register and giving that scratch register as an argument. This means if we store indices with our regular 1-indexing, we‚Äôll have to add 6 every time we want to fetch the tree values, and subtract 6 every time we want to compute the next index. We really want to avoid these extra ALU operations if possible.</p> <p data-svelte-h="svelte-xha2vt">It turns out we can keep our indices in the 7-indexed scheme thanks to the vmultiply_add operation. Normally, we‚Äôd compute left_node = parent_node x 2, but if we instead store parent_node+6, we can compute left_node+6 = (parent_node+6) x 2 - 6. This means we can directly load from our index registers while still cheaply doubling node indices.</p> <h2 id="memory" data-svelte-h="svelte-9bafq">Memory</h2> <p data-svelte-h="svelte-11yl1g">I initially wrote up a version of this problem where we try to load in as much of the tree as possible to scratch, then use those values throughout the problem. For the same reason earlier mentioned about main memory addressing, this is impossible - there are no instructions capable of double indirection into scratch memory. If we have a scratch address in a scratch register, we can‚Äôt actually dereference that scratch address and fetch or do math with the result. This means, for every round and value, we need to either:</p> <ol data-svelte-h="svelte-8b9s3u"><li>Fetch the required tree value straight from main memory, as the load instruction does allow (and in fact requires) double indirection.</li> <li>Do something clever using instructions like vectorized select to reduce the memory pressure, particularly on less complicated levels of the tree. For example, on level 0, all of the scratch values xor with the same tree value, so we can just load it to a register and reuse it for all the scratch values without any loading logic.</li></ol> <p data-svelte-h="svelte-12oqu2m">If we go with idea 1 for every level of our tree, we‚Äôll need 16 rounds of loads for each of the 256 values in our batch, and at 2 loads per cycle that‚Äôs at least 2048 cycles. Thanks to the specific test case design and the VSELECT instruction, there‚Äôs a lot we can do to match the memory and compute cost.</p> <h3 id="muxing" data-svelte-h="svelte-wn82h4">Muxing</h3> <p data-svelte-h="svelte-1r1k23z">(For this section, we‚Äôll go back to assuming our indices are 1-indexed)</p> <p data-svelte-h="svelte-xr3tbp">We want to replace memory operations with compute operations to balance out the workloads. On layer 0, as mentioned, we‚Äôll just load the first tree value once and use it for every element.</p> <p data-svelte-h="svelte-1eoavzo">On layers 1, 2, and 3, we need to load in only 2, 4, and 8 values respectively (unlike layer 10 where there‚Äôs as many as 1024 possible values we could be asked to load in, with likely little to no reuse among our 256 elements). To take advantage of these small layers, we can implement a MUX (multiplexing) tree, which attempts to efficiently convert the vector of indices [a,b,c,d,e,f,g,h] to a vector of [arr[a],arr[b],arr[c],arr[d],arr[e],arr[f],arr[g],arr[h]] by taking advantage of assumptions on the range of the values of the indices.</p> <p data-svelte-h="svelte-1mowci7">For this, we‚Äôll need the VSELECT instruction. VSELECT takes three vector registers we can call s, a, and b. VSELECT functions like an if-else statement on the condition of s. If index i of s is nonzero, the output register gets a[i] in slot i, otherwise it gets b[i].</p> <p data-svelte-h="svelte-1baxlyb">In the 2-value case, the mux tree is pretty easy. All our indices are either 2 or 3, so we &amp; our index vector with 1 to get a vector of 0 or 1 based on if we need to xor that value with tree[2] (even) or tree[3] (odd). Now we set our output vector to the VSELECT of the vector of tree[2] and the vector of tree[3\,] selecting on our &amp;1 vector so that the even values (where there‚Äôs a 0) will get index 2 and the odd values will get index 3. Note that we broadcast our two tree values into full vector registers so that they are in the form required by the VSELECT instruction.</p> <p data-svelte-h="svelte-iskkee">In the 4-value case, we start building up the MUX tree. The idea is that we can VSELECT the bottom bit for each case of the top bit, then VSELECT those two cases together. We‚Äôre working with indices 4, 5, 6, and 7, with bottom bits 0b00, 0b01, 0b10, 0b11. First we VSELECT together tree[4] and tree[5] based on the bottom bits (so selecting via &amp;1) - this puts the correct value in place for 0b00 and 0b01, but garbage value in place for 0b10, 0b11. Next, we VSELECT together tree[6] and tree[7] on the bottom bits into a separate register, which gives us the right values for 0b10 and 0b11 and garbage for the others. Finally, we &amp;2 the indices to get the top bit, which tells VSELECT which register that index should pull its value from (while the other register will have a garbage value). This combines our two intermediate vectors into one final correct vector.</p> <p data-svelte-h="svelte-cd2ftd">We can build this tree up arbitrarily tall, but it will obviously cost more registers and compute if we do it later and later in the tree since we‚Äôll have more and more values to mux together. Since there are 32 batches of 8 in our input, we‚Äôll need 0, 32, 96, 224, and 480 VSELECTs for each round at level 0, 1, 2, 3, and 4 in the tree (and each of these levels appears twice). We only have on the order of 1000 total VSELECTS we can use since we only get one per cycle.</p> <p data-svelte-h="svelte-xf56yd">If we load all but levels 0-3 of the tree, we will load 8 levels of the tree and require 2048 loads, taking 1024 cycles. This will require 704 VSELECTs and a handful more vector ops, so resource consumption across the instruction types is now much more balanced.</p> <h1 id="symbolic-intermediate-representation" data-svelte-h="svelte-eaor50">Symbolic Intermediate Representation</h1> <p data-svelte-h="svelte-1smcvtv">We could try to orchestrate and fit the instructions to the CPU ourselves, but most likely this will create gaps that are difficult to manually handle. Instead, we‚Äôre going to write our code in an intermediate representation (a version of the program that operates on symbolic registers rather than real data or real scratch addresses), and then write a compiler pass that compresses and pipelines it automatically. This will also make it easier to take advantage of ALU operations later.</p> <p data-svelte-h="svelte-wx1mvn">The intermediate representation scheme we‚Äôll write is relatively simple, but hits some quirks around loading and storing. It has two rough assumptions:</p> <ol data-svelte-h="svelte-1ojh4y6"><li>All registers are treated as 8-aligned vector registers</li> <li>Every instruction writes to a fresh register. The compiler will handle checking when a register can be ‚Äúclobbered‚Äù ie written over due to nothing needing to read from it anymore.</li></ol> <p data-svelte-h="svelte-njadbf">One exception is that loading the tree from indices requires 8 loads all to the same vector, because it only loads one scalar at a time, so the compiler will have to do some extra offset computations when lowering this instruction from IR to a real instruction.</p> <p data-svelte-h="svelte-eoc7ou">With this and a bunch of small implementation details, we can write our entire computation in an IR form that doesn‚Äôt care what the input values are, as long as we‚Äôre careful to write each instruction correctly. A sample of these is shown below:</p> <!-- HTML_TAG_START --><pre class="shiki poimandres" style="background-color:#1b1e28;color:#a6accd" tabindex="0"><code><span class="line"><span style="color:#A6ACCD">@</span><span style="color:#ADD7FF">dataclass</span><span style="color:#A6ACCD">(</span><span style="color:#E4F0FB">frozen</span><span style="color:#91B4D5">=</span><span style="color:#5DE4C7">True</span><span style="color:#A6ACCD">)</span></span>
<span class="line"><span style="color:#91B4D5">class</span><span style="color:#ADD7FF"> const_register</span><span style="color:#A6ACCD">:</span></span>
<span class="line"><span style="color:#A6ACCD">    name: </span><span style="color:#A6ACCDC0">str</span></span>
<span class="line"><span style="color:#A6ACCD">    is_scalar: </span><span style="color:#A6ACCDC0">bool</span></span>
<span class="line"></span>
<span class="line"></span>
<span class="line"><span style="color:#A6ACCD">@</span><span style="color:#ADD7FF">dataclass</span><span style="color:#A6ACCD">(</span><span style="color:#E4F0FB">frozen</span><span style="color:#91B4D5">=</span><span style="color:#5DE4C7">True</span><span style="color:#A6ACCD">)</span></span>
<span class="line"><span style="color:#91B4D5">class</span><span style="color:#ADD7FF"> index_register</span><span style="color:#A6ACCD">:</span></span>
<span class="line"><span style="color:#A6ACCD">    batch_index: </span><span style="color:#A6ACCDC0">int</span></span>
<span class="line"><span style="color:#A6ACCD">    round: </span><span style="color:#A6ACCDC0">int</span></span>
<span class="line"><span style="color:#A6ACCD">    is_doubled: </span><span style="color:#A6ACCDC0">bool</span></span>
<span class="line"></span>
<span class="line"><span style="color:#A6ACCD">@</span><span style="color:#ADD7FF">dataclass</span><span style="color:#A6ACCD">(</span><span style="color:#E4F0FB">frozen</span><span style="color:#91B4D5">=</span><span style="color:#5DE4C7">True</span><span style="color:#A6ACCD">)</span></span>
<span class="line"><span style="color:#91B4D5">class</span><span style="color:#ADD7FF"> value_register</span><span style="color:#A6ACCD">:</span></span>
<span class="line"><span style="color:#A6ACCD">    batch_index: </span><span style="color:#A6ACCDC0">int</span></span>
<span class="line"><span style="color:#A6ACCD">    round: </span><span style="color:#A6ACCDC0">int</span></span>
<span class="line"><span style="color:#A6ACCD">    stage: </span><span style="color:#A6ACCDC0">int</span></span>
<span class="line"></span>
<span class="line"><span style="color:#A6ACCD">@</span><span style="color:#ADD7FF">dataclass</span><span style="color:#A6ACCD">(</span><span style="color:#E4F0FB">frozen</span><span style="color:#91B4D5">=</span><span style="color:#5DE4C7">True</span><span style="color:#A6ACCD">)</span></span>
<span class="line"><span style="color:#91B4D5">class</span><span style="color:#ADD7FF"> tree_address_register</span><span style="color:#A6ACCD">:</span></span>
<span class="line"><span style="color:#A6ACCD">    batch_index: </span><span style="color:#A6ACCDC0">int</span></span>
<span class="line"><span style="color:#A6ACCD">    round: </span><span style="color:#A6ACCDC0">int</span></span>
<span class="line"></span>
<span class="line"><span style="color:#A6ACCD">@</span><span style="color:#ADD7FF">dataclass</span><span style="color:#A6ACCD">(</span><span style="color:#E4F0FB">frozen</span><span style="color:#91B4D5">=</span><span style="color:#5DE4C7">True</span><span style="color:#A6ACCD">)</span></span>
<span class="line"><span style="color:#91B4D5">class</span><span style="color:#ADD7FF"> tree_register</span><span style="color:#A6ACCD">:</span></span>
<span class="line"><span style="color:#A6ACCD">    batch_index: </span><span style="color:#A6ACCDC0">int</span></span>
<span class="line"><span style="color:#A6ACCD">    round: </span><span style="color:#A6ACCDC0">int</span></span>
<span class="line"><span style="color:#A6ACCD">    slots_filled: </span><span style="color:#A6ACCDC0">int</span></span></code></pre><!-- HTML_TAG_END --> <p data-svelte-h="svelte-1ciyndb">Each IR instruction is a real operation, but written to operate on instantiations of these imaginary registers instead of a real scratch address. For example, when computing the first hash stage of a value, inside a double for loop that tells us which batch index and round we‚Äôre on:</p> <!-- HTML_TAG_START --><pre class="shiki poimandres" style="background-color:#1b1e28;color:#a6accd" tabindex="0"><code><span class="line"><span style="color:#767C9DB0;font-style:italic"># Hash stage 1</span></span>
<span class="line"><span style="color:#A6ACCD">instrs.append((</span></span>
<span class="line"><span style="color:#A6ACCD">	"</span><span style="color:#5DE4C7">valu</span><span style="color:#A6ACCD">"</span><span style="color:#A6ACCD">,</span></span>
<span class="line"><span style="color:#A6ACCD">	"</span><span style="color:#5DE4C7">vmultiply_add</span><span style="color:#A6ACCD">"</span><span style="color:#A6ACCD">,</span></span>
<span class="line"><span style="color:#A6ACCD">	value_register(</span><span style="color:#E4F0FB">batch_index</span><span style="color:#91B4D5">=</span><span style="color:#A6ACCD">,</span><span style="color:#E4F0FB">round</span><span style="color:#91B4D5">=</span><span style="color:#A6ACCD">,</span><span style="color:#E4F0FB">stage</span><span style="color:#91B4D5">=</span><span style="color:#5DE4C7">2</span><span style="color:#A6ACCD">),</span></span>
<span class="line"><span style="color:#A6ACCD">	value_register(</span><span style="color:#E4F0FB">batch_index</span><span style="color:#91B4D5">=</span><span style="color:#A6ACCD">,</span><span style="color:#E4F0FB">round</span><span style="color:#91B4D5">=</span><span style="color:#A6ACCD">,</span><span style="color:#E4F0FB">stage</span><span style="color:#91B4D5">=</span><span style="color:#5DE4C7">1</span><span style="color:#A6ACCD">),</span></span>
<span class="line"><span style="color:#A6ACCD">	const_register(</span><span style="color:#E4F0FB">name</span><span style="color:#91B4D5">=</span><span style="color:#A6ACCD">"</span><span style="color:#5DE4C7">HASH_1_MUL</span><span style="color:#A6ACCD">"</span><span style="color:#A6ACCD">, </span><span style="color:#E4F0FB">is_scalar</span><span style="color:#91B4D5">=</span><span style="color:#5DE4C7">False</span><span style="color:#A6ACCD">),</span></span>
<span class="line"><span style="color:#A6ACCD">	const_register(</span><span style="color:#E4F0FB">name</span><span style="color:#91B4D5">=</span><span style="color:#A6ACCD">"</span><span style="color:#5DE4C7">HASH_1_ADD</span><span style="color:#A6ACCD">"</span><span style="color:#A6ACCD">, </span><span style="color:#E4F0FB">is_scalar</span><span style="color:#91B4D5">=</span><span style="color:#5DE4C7">False</span><span style="color:#A6ACCD">),</span></span>
<span class="line"><span style="color:#A6ACCD">))</span></span></code></pre><!-- HTML_TAG_END --> <p data-svelte-h="svelte-5417so">The fresh register property mentioned earlier gives this IR code the really nice property that once we‚Äôve emitted all our instructions, we can verify that they perform the correct computation by simulating the instructions on an infinite register machine that always allocates a fresh register on each write.</p> <h1 id="compiling" data-svelte-h="svelte-1mq7nxo">Compiling</h1> <p data-svelte-h="svelte-ejxmx7">We‚Äôd now like our compiler to figure out how to pack our instructions into the given slots for us. With our IR, the first pass of this is pretty easy. We need to know which instructions depend on which so that each instruction that reads from scratch always has its desired inputs available. Any two instructions that have all their inputs available can be immediately scheduled.</p> <p data-svelte-h="svelte-q6nbic">We can generate a dependency graph from our instructions, where we say A depends on B (B-&gt;A) if B writes a register that A reads. Once we‚Äôve constructed this dependency graph, we can greedily grab sets of orphaned nodes from the graph (nodes with no parents, meaning all the registers are ready to use) and append them to the current cycle until we‚Äôre out of instructions or out of slots in the cycle. We can keep track of scratch registers at the same time, where any register that no longer has future readers will be evicted from the used scratch.</p> <h1 id="first-shot-2107-cycles" data-svelte-h="svelte-rqsxow">First Shot (2107 cycles)</h1> <p data-svelte-h="svelte-eavk78">We‚Äôll skip the mux tree for now and check that our compiler works from end to end.</p> <p data-svelte-h="svelte-5rw3rn">As we expect, we‚Äôre underutilizing the vector ALU because of loads - almost exactly to the degree we expect, 2048 load cycles + extra overhead like loading constants and final stores.</p> <img src="./anthropic/01_first-shot-trace.png" alt="First shot trace" style="margin: 1em 0em"> <h1 id="mux-level-0-1860-cycles" data-svelte-h="svelte-1ivpyoa">‚ÄúMux‚Äù Level 0 (1860 cycles)</h1> <p data-svelte-h="svelte-1slhxew">We‚Äôll now directly address level 0‚Äôs one node as a constant. Now all six VALU lanes are fully utilized for the first ~200 cycles and again later on (once we‚Äôve looped back around to level 0) for another 200 cycles.</p> <p data-svelte-h="svelte-qe6vyt">Those 200 cycles, zoomed in:</p> <img src="./anthropic/02_mux0-zoomed.png" alt="Mux 0 zoomed" style="margin: 1em 0em"> <p data-svelte-h="svelte-pcb7i3">The entire trace, with the second set of 200 cycles highlighted:</p> <img src="./anthropic/03_mux0-full-trace.png" alt="Mux 0 full trace" style="margin: 1em 0em"> <h1 id="mux-level-1-1722-cycles" data-svelte-h="svelte-12gyf8n">Mux Level 1 (1722 cycles)</h1> <p data-svelte-h="svelte-1uq08ym">Because of our indexing optimization, we have to be a little careful how we mux, but thankfully just by shuffling the two outputs in each VSELECT we can assign the mux outputs however we want (as long as the input index range is contiguous, so that their bottom bits uniquely define them).</p> <img src="./anthropic/04_mux1-trace.png" alt="Mux 1 trace" style="margin: 1em 0em"> <h1 id="mux-level-2-1655-cycles" data-svelte-h="svelte-1fze339">Mux Level 2 (1655 cycles)</h1> <p data-svelte-h="svelte-c43jgt">The speedups are starting to stall, likely because our compiler isn‚Äôt smart enough to rush through one of the batches so it can get to the load-heavy batches and start running the load bottleneck. We have load bubbles of roughly 300 cycles.</p> <img src="./anthropic/05_mux2-load-bubbles.png" alt="Mux 2 load bubbles" style="margin: 1em 0em"> <h1 id="mux-level-3-1620-cycles-but-out-of-registers" data-svelte-h="svelte-hv8k2d">Mux Level 3 (1620 cycles, but out of registers)</h1> <p data-svelte-h="svelte-clk2zw">In addition to adding mux level 3, I went back and optimized the logic for mux 1 and 2 (mainly reusing the value&amp;1 computed in the previous iteration). Not only are we losing our speedups, we also can‚Äôt actually run the code without at least 1900 registers.</p> <p data-svelte-h="svelte-1v7ljf6">This is mainly because of bigger and bigger bubbles in loading; our compiler isn‚Äôt smart enough to rush to the bounded loading steps. We‚Äôre running out of registers because our compiler schedules all the heavy mux level 3 operations at once among all the batches, and they consume a lot of extra registers before they can be freed.</p> <img src="./anthropic/06_mux3-register-outage.png" alt="Mux 3 register outage" style="margin: 1em 0em"> <h1 id="mux-level-3-rotated-input-1548-cycles" data-svelte-h="svelte-r4hn4r">Mux Level 3, Rotated Input (1548 cycles)</h1> <p data-svelte-h="svelte-168213b">We can sidestep this problem really simply - we just need to write our input in a way that doesn‚Äôt clog up the registers when everyone gets to muxing level 3. We do this by emitting instructions for all rounds of batch 1, then all rounds of batch 2, etc. instead of all round 1s, all round 2s, etc. By doing this, not only do we no longer run out of registers, but we also smear the computation much more evenly through the middle - the big bubble in the fifth and sixth lane is completely gone.</p> <p data-svelte-h="svelte-1ky94c8">This is not a scientific result, but a fairly lucky coincidence that manages to spread out the mux level 3 enough to keep our registers open. It saves us a lot of time redesigning the compiler.</p> <p data-svelte-h="svelte-1cerr1s">The coloring changed because I updated the labeling to use the names of the IR registers instead of the true underlying register indices.</p> <img src="./anthropic/07_mux3-input-rotation.png" alt="Mux 3 input rotation" style="margin: 1em 0em"> <h1 id="optimize-preamble-1498-cycles" data-svelte-h="svelte-1dsa12">Optimize Preamble (1498 cycles)</h1> <p data-svelte-h="svelte-fq06em">Right now we load_const all our constants, which clogs up the preamble quite a bit with a stuffed load unit. A good chunk of our constants can be computed directly from other constants, like HASH_6_RIGHTSHIFT with the value 16 that can be computed as 4x4.</p> <p data-svelte-h="svelte-vf4rvr">We can also start using the ALU earlier. Our code doesn‚Äôt do hotpath analysis, so it takes a bit of loading before the ALU can start crunching. Just by moving the loading of tree node 0 a little earlier, we can start the ALU much sooner and overlap it with the last few loads needed for later stages.</p> <p data-svelte-h="svelte-1die5vv">Before:</p> <img src="./anthropic/08_preamble-before.png" alt="Preamble before" style="margin: 1em 0em"> <p data-svelte-h="svelte-1j81ob0">After:</p> <img src="./anthropic/09_preamble-after.png" alt="Preamble after" style="margin: 1em 0em"> <h1 id="use-the-rest-of-the-alu-1240-cycles" data-svelte-h="svelte-1gmrokg">Use the rest of the ALU (1240 cycles)</h1> <p data-svelte-h="svelte-1f6zl1a">We have 12 ALU operations unused. The first 8 are easy to use - any vector ALU op that isn‚Äôt a broadcast operation or vmultiply_add operation can be split into 8 of the same scalar operation with the register indices updated.</p> <p data-svelte-h="svelte-19k3t64">For the last 4 slots, we have to be a little smarter. We can schedule half of a vector instruction by turning the first 4 slots into ALU ops, but leave it on the graph and mark it as half done instead of fully done. We‚Äôll prioritize scheduling the other half of these vector instructions on the next cycle‚Äôs ALU so that the vector is half-done for only one cycle.</p> <p data-svelte-h="svelte-hs2zj9">This predictably gives us a huge performance jump, as we go from 6 to 7.5 vector ALU ops per cycle. Naively, this should give us at most a 25% performance increase, which would ideally put us at ~1200 cycles, but obviously there‚Äôs some non-ALU overhead. This also puts us ahead of Claude‚Äôs best performance.</p> <img src="./anthropic/10_alu-expanded.png" alt="ALU expanded" style="margin: 1em 0em"> <h1 id="optimize-tail-1218-cycles" data-svelte-h="svelte-1izk9uu">Optimize Tail (1218 cycles)</h1> <p data-svelte-h="svelte-1sgedn5">While the aforementioned input rotation is great for fixing the register problem, it creates a long tail of inputs that poorly utilize the compute at the end, as there aren‚Äôt enough batch elements to parallelize (manifesting as a staircase pattern). We can slightly improve on this by adding the last four batches in the original order, round-by-round, so that there will be more parallel work at any given moment near the end.</p> <p data-svelte-h="svelte-wnw36k">We again get lucky with no register outage, likely thanks to (1) the previous batches creating a long tail for our instructions to fill in which smears the extra VSELECT registers, and (2) the new batches we scheduled not being large enough to exert too much register pressure. We pick the last four batches because they achieve the best performance.</p> <img src="./anthropic/11_tail-optimized.png" alt="Tail optimized" style="margin: 1em 0em"> <h1 id="final-thoughts" data-svelte-h="svelte-5xxd9f">Final thoughts</h1> <p data-svelte-h="svelte-1tuudv0">There‚Äôs quite a lot more compiler optimization work here that could be done, but given I‚Äôm approaching my own theoretical lower bound, I think these returns will be quickly diminishing. These efforts would mainly go towards trying to solve for the best packing, through things like hot path analysis to avoid the remaining tail at the end and smarter register allocation. We do some manual shuffling of instructions in the preamble that we‚Äôd really prefer the compiler figure out for us, and we would rather our compiler be agnostic to the rotation and exact instruction stream order of the IR.</p> <p data-svelte-h="svelte-aa5a50">There‚Äôs about 80 cycles of load bubbles left, which if further optimized would get us within a few percent of the ALU lower bound mentioned earlier. Under the current compute graph this may not be possible with limited remaining ALU room, but there‚Äôs plenty of other inefficiencies in the loading operations (namely in loading addresses for main memory) I didn‚Äôt work on because it would‚Äôve required significant updates to the IR scheme.</p> <p data-svelte-h="svelte-1jckajt">I achieved a final score of 1218 cycles, which I‚Äôm pretty happy with. I ran it on the commented-out test case on different args to show we didn‚Äôt overfit to the main test case and actually get even better relative speedups on smaller test cases:</p> <!-- HTML_TAG_START --><pre class="shiki poimandres" style="background-color:#1b1e28;color:#a6accd" tabindex="0"><code><span class="line"><span style="color:#A6ACCD">forest_height</span><span style="color:#91B4D5">=</span><span style="color:#5DE4C7">2</span><span style="color:#A6ACCD">, rounds</span><span style="color:#91B4D5">=</span><span style="color:#5DE4C7">4</span><span style="color:#A6ACCD">, batch_size</span><span style="color:#91B4D5">=</span><span style="color:#5DE4C7">128</span></span>
<span class="line"><span style="color:#A6ACCD">CYCLES:  </span><span style="color:#5DE4C7">156</span></span>
<span class="line"><span style="color:#A6ACCD">Speedup over baseline:  </span><span style="color:#5DE4C7">947.0128205128206</span></span>
<span class="line"><span style="color:#A6ACCD">forest_height</span><span style="color:#91B4D5">=</span><span style="color:#5DE4C7">3</span><span style="color:#A6ACCD">, rounds</span><span style="color:#91B4D5">=</span><span style="color:#5DE4C7">5</span><span style="color:#A6ACCD">, batch_size</span><span style="color:#91B4D5">=</span><span style="color:#5DE4C7">128</span></span>
<span class="line"><span style="color:#A6ACCD">CYCLES:  </span><span style="color:#5DE4C7">233</span></span>
<span class="line"><span style="color:#A6ACCD">Speedup over baseline:  </span><span style="color:#5DE4C7">634.0515021459228</span></span>
<span class="line"><span style="color:#A6ACCD">forest_height</span><span style="color:#91B4D5">=</span><span style="color:#5DE4C7">4</span><span style="color:#A6ACCD">, rounds</span><span style="color:#91B4D5">=</span><span style="color:#5DE4C7">6</span><span style="color:#A6ACCD">, batch_size</span><span style="color:#91B4D5">=</span><span style="color:#5DE4C7">128</span></span>
<span class="line"><span style="color:#A6ACCD">CYCLES:  </span><span style="color:#5DE4C7">251</span></span>
<span class="line"><span style="color:#A6ACCD">Speedup over baseline:  </span><span style="color:#5DE4C7">588.5816733067729</span></span>
<span class="line"><span style="color:#A6ACCD">forest_height</span><span style="color:#91B4D5">=</span><span style="color:#5DE4C7">2</span><span style="color:#A6ACCD">, rounds</span><span style="color:#91B4D5">=</span><span style="color:#5DE4C7">4</span><span style="color:#A6ACCD">, batch_size</span><span style="color:#91B4D5">=</span><span style="color:#5DE4C7">256</span></span>
<span class="line"><span style="color:#A6ACCD">CYCLES:  </span><span style="color:#5DE4C7">284</span></span>
<span class="line"><span style="color:#A6ACCD">Speedup over baseline:  </span><span style="color:#5DE4C7">520.1901408450705</span></span>
<span class="line"><span style="color:#A6ACCD">forest_height</span><span style="color:#91B4D5">=</span><span style="color:#5DE4C7">3</span><span style="color:#A6ACCD">, rounds</span><span style="color:#91B4D5">=</span><span style="color:#5DE4C7">5</span><span style="color:#A6ACCD">, batch_size</span><span style="color:#91B4D5">=</span><span style="color:#5DE4C7">256</span></span>
<span class="line"><span style="color:#A6ACCD">CYCLES:  </span><span style="color:#5DE4C7">419</span></span>
<span class="line"><span style="color:#A6ACCD">Speedup over baseline:  </span><span style="color:#5DE4C7">352.5871121718377</span></span>
<span class="line"><span style="color:#A6ACCD">forest_height</span><span style="color:#91B4D5">=</span><span style="color:#5DE4C7">4</span><span style="color:#A6ACCD">, rounds</span><span style="color:#91B4D5">=</span><span style="color:#5DE4C7">6</span><span style="color:#A6ACCD">, batch_size</span><span style="color:#91B4D5">=</span><span style="color:#5DE4C7">256</span></span>
<span class="line"><span style="color:#A6ACCD">CYCLES:  </span><span style="color:#5DE4C7">462</span></span>
<span class="line"><span style="color:#A6ACCD">Speedup over baseline:  </span><span style="color:#5DE4C7">319.7705627705628</span></span>
<span class="line"><span style="color:#A6ACCD">forest_height</span><span style="color:#91B4D5">=</span><span style="color:#5DE4C7">10</span><span style="color:#A6ACCD">, rounds</span><span style="color:#91B4D5">=</span><span style="color:#5DE4C7">16</span><span style="color:#A6ACCD">, batch_size</span><span style="color:#91B4D5">=</span><span style="color:#5DE4C7">256</span></span>
<span class="line"><span style="color:#A6ACCD">CYCLES:  </span><span style="color:#5DE4C7">1218</span></span>
<span class="line"><span style="color:#A6ACCD">Speedup over baseline:  </span><span style="color:#5DE4C7">121.29228243021346</span></span>
<span class="line"><span style="color:#A6ACCD">forest_height</span><span style="color:#91B4D5">=</span><span style="color:#5DE4C7">10</span><span style="color:#A6ACCD">, rounds</span><span style="color:#91B4D5">=</span><span style="color:#5DE4C7">16</span><span style="color:#A6ACCD">, batch_size</span><span style="color:#91B4D5">=</span><span style="color:#5DE4C7">256</span></span>
<span class="line"><span style="color:#A6ACCD">CYCLES:  </span><span style="color:#5DE4C7">1218</span></span>
<span class="line"><span style="color:#A6ACCD">Speedup over baseline:  </span><span style="color:#5DE4C7">121.29228243021346</span></span></code></pre><!-- HTML_TAG_END --> <p data-svelte-h="svelte-198ivlo">Below is a simulator that shows the entire computation being performed in my IR cycle-by-cycle.</p> <div class="trace-viewer font-mono bg-gray-950 text-gray-200 p-4 rounded-lg border border-gray-800 shadow-2xl h-[800px] flex flex-col"><div class="header mb-4 border-b border-gray-800 pb-4"><div class="flex justify-between items-center mb-3" data-svelte-h="svelte-1xohaki"><h2 class="text-xl font-bold text-gray-100 flex items-center gap-2"><span class="w-3 h-3 rounded-full bg-green-500 animate-pulse"></span>
        IR Processor Trace</h2></div> <div style="position: relative; width: 100%; height: 1.25rem; border-radius: 9999px; margin-bottom: 0.75rem; cursor: pointer; background: #1e293b;"><div style="position: absolute; top: 0; left: 0; height: 100%; border-radius: 9999px; transition: width 75ms; width: Infinity%; background: #2563eb;"></div> <div style="position: absolute; top: 50%; transform: translateY(-50%); width: 1rem; height: 1rem; border-radius: 9999px; background: white; left: calc(Infinity% - 8px); box-shadow: 0 0 10px rgba(37,99,235,0.8);"></div> <input type="range" min="0" max="0" value="1" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; opacity: 0; cursor: pointer; margin: 0;"></div> <div style="display: grid; grid-template-columns: repeat(7, 1fr); gap: 4px; align-items: stretch;"><button class="btn" >‚Äπ‚Äπ‚Äπ</button> <button class="btn" >‚Äπ‚Äπ</button> <button class="btn" >‚Äπ</button> <div style="display: flex; align-items: center; justify-content: center; text-align: center;"><span class="text-white font-bold text-sm">1</span><span class="text-gray-500 text-sm ml-1">/ 0</span></div> <button class="btn" disabled>‚Ä∫</button> <button class="btn" disabled>‚Ä∫‚Ä∫</button> <button class="btn" disabled>‚Ä∫‚Ä∫‚Ä∫</button></div></div> <div class="flex-1 grid grid-cols-12 gap-6 min-h-0"><div class="col-span-4 flex flex-col min-h-0 border-r border-gray-800 pr-4"> <h3 class="text-xs font-bold text-gray-500 uppercase tracking-wider mb-2" data-svelte-h="svelte-1d49xy">Batch Progress</h3> <div class="bg-gray-900/50 rounded-lg p-2 mb-3 border border-gray-800" style="flex-shrink: 0;"><svg viewBox="0 0 200 100" width="100%" style="display: block;" preserveAspectRatio="xMinYMin meet"><text x="16" y="3.5" fill="#4b5563" font-size="3" font-family="monospace" text-anchor="middle">0</text><text x="61" y="3.5" fill="#4b5563" font-size="3" font-family="monospace" text-anchor="middle">4</text><text x="106" y="3.5" fill="#4b5563" font-size="3" font-family="monospace" text-anchor="middle">8</text><text x="151" y="3.5" fill="#4b5563" font-size="3" font-family="monospace" text-anchor="middle">12</text><text x="196" y="3.5" fill="#4b5563" font-size="3" font-family="monospace" text-anchor="middle">16</text></svg></div>  <h3 class="text-xs font-bold text-gray-500 uppercase tracking-wider mb-2" data-svelte-h="svelte-bt5ft4">Instructions Executing</h3> <div class="overflow-y-auto pr-2 custom-scrollbar flex-1"><div class="text-gray-600 italic text-sm py-4 text-center" data-svelte-h="svelte-1vh739g">No instructions (Bubble/Pause)</div> </div></div> <div class="col-span-8 flex flex-col min-h-0"><div class="flex justify-between items-end mb-20px"><h3 class="text-xs font-bold text-gray-500 uppercase tracking-wider">Live Registers (0)</h3> <div style="display: flex; flex-wrap: wrap; gap: 6px; font-size: 10px; margin-bottom:6px;"><span class="reg-pill" style="background-color: #1e3a8a; color: #bfdbfe; border: 1px solid #1d4ed8;; padding: 2px 6px; border-radius: 9999px; display: inline-block;">val </span><span class="reg-pill" style="background-color: #064e3b; color: #a7f3d0; border: 1px solid #047857;; padding: 2px 6px; border-radius: 9999px; display: inline-block;">idx </span><span class="reg-pill" style="background-color: #78350f; color: #fde68a; border: 1px solid #b45309;; padding: 2px 6px; border-radius: 9999px; display: inline-block;">tree </span><span class="reg-pill" style="background-color: #92400e; color: #fcd34d; border: 1px solid #d97706;; padding: 2px 6px; border-radius: 9999px; display: inline-block;">const </span><span class="reg-pill" style="background-color: #831843; color: #fbcfe8; border: 1px solid #be185d;; padding: 2px 6px; border-radius: 9999px; display: inline-block;">mux </span><span class="reg-pill" style="background-color: #2e1065; color: #ddd6fe; border: 1px solid #5b21b6;; padding: 2px 6px; border-radius: 9999px; display: inline-block;">hash </span><span class="reg-pill" style="background-color: #312e81; color: #c7d2fe; border: 1px solid #4338ca;; padding: 2px 6px; border-radius: 9999px; display: inline-block;">mod </span><span class="reg-pill" style="background-color: #1f2937; color: #d1d5db; border: 1px solid #4b5563;; padding: 2px 6px; border-radius: 9999px; display: inline-block;">mem </span></div></div> <div class="bg-gray-900/50 rounded-lg p-4 flex-1 overflow-y-auto custom-scrollbar border border-gray-800 shadow-inner"><div class="flex items-center justify-center h-full text-blue-400 animate-pulse" data-svelte-h="svelte-1t6rc8p">Loading Trace Data...</div></div></div></div></div> <style data-svelte-h="svelte-7vufmq">/* Custom Scrollbar for dark theme */
  .custom-scrollbar::-webkit-scrollbar {
    width: 6px;
  }
  .custom-scrollbar::-webkit-scrollbar-track {
    background: #111827; 
  }
  .custom-scrollbar::-webkit-scrollbar-thumb {
    background: #374151; 
    border-radius: 3px;
  }
  .custom-scrollbar::-webkit-scrollbar-thumb:hover {
    background: #4b5563; 
  }

  .btn {
    @apply px-3 py-1 bg-gray-800 hover:bg-gray-700 text-gray-200 text-xs font-semibold rounded border border-gray-600 transition-colors disabled:opacity-50 disabled:cursor-not-allowed;
  }

  .reg-pill {
    white-space: nowrap;
  }</style></div> </article></div></main> <footer class="svelte-1fvv9s8" data-svelte-h="svelte-egjb02"><p class="svelte-1fvv9s8">Made by <a href="https://sambhavg.github.io/" target="_blank">Sambhav Gupta</a></p> </footer> </div> 
			
			<script>
				{
					__sveltekit_bxy18b = {
						base: new URL(".", location).pathname.slice(0, -1),
						assets: "/blog"
					};

					const element = document.currentScript.parentElement;

					const data = [null,null];

					Promise.all([
						import("./_app/immutable/entry/start.8eeIORQm.js"),
						import("./_app/immutable/entry/app.BXGYdaLC.js")
					]).then(([kit, app]) => {
						kit.start(app, element, {
							node_ids: [0, 3],
							data,
							form: null,
							error: null
						});
					});
				}
			</script>
		</div>
	</body>
</html>
